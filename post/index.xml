<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Co1driver 的个人博客</title>
    <link>https://chongg039.cn/post/</link>
    <description>Recent content in Posts on Co1driver 的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright 2014-{year}</copyright>
    <lastBuildDate>Tue, 22 Dec 2020 15:28:15 +0800</lastBuildDate><atom:link href="https://chongg039.cn/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>极贰刷Openwrt及配置记录</title>
      <link>https://chongg039.cn/post/openwrt-config/</link>
      <pubDate>Tue, 22 Dec 2020 15:28:15 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/openwrt-config/</guid>
      <description>极路由-极贰(HC5761)刷openwrt19.07，以及各种配置小记。
0. 刷u-boot 极路由申请开发者权限，刷入不死u-boot是必要的先行步骤，这里不再赘述。 有疑问的请自行google。
注意第一次进入u-boot时最好将之前的配置备份一下。
1. 选择并烧录对应的openwrt版本 进入openwrt官网的Download页面，在Stable Release Builds目录下找到自己合适的版本的固件。 这里的极贰对应的固件目录选择/19.07.5/targets/ramips/mt7620/hc5761-squashfs-sysupgrade.bin
然后将路由器断电断wan，lan口和电脑网口直连，按住reset后上电5s左右至灯快速闪烁，松开reset。
待电脑分配到ip后（如果不能需要手动指定一下192.168.1.x），进入192.168.1.1烧录刚才下载好的固件， 等待重启。
注：本文我采用了撰写本文时最新的19.07.05，目前没有发现问题。但在此两周前的最新版本19.07.04中 经常出现断流，我的这台极贰高发于凌晨零点刚过那一刻。 后来查阅内核日志google了一下，发现同样的问题被发现于19.07.04中： https://bugs.openwrt.org/index.php?do=details&amp;amp;task_id=3344 该文章的解决方案中说明了降级到19.07.03便没有再出现过此类问题。我在动笔撰写该文章的前几天，openwrt官方 释出了19.07.05版本，便采用了该版本的固件且暂时没有重现上述问题。特此记录。 2. 换肤 openwrt默认的界面比较丑，容易影响到接下来的工作心情，所以上来先换个皮。
我们先更换一下opkg的源为清华的镜像源：链接
然后执行一下opkg update，当重启或者找不到包时都需要执行一遍该命令。
皮肤我采用了luci-theme-argon：链接
安装前为了访问https的链路，需要
opkg install libustream-openssl 或 opkg install ca-certificates 为了支持中文界面，再安装一个中文语言包：
opkg install luci-i18n-base-zh-cn``` ![a1SIyy](https://cdn.jsdelivr.net/gh/chongg039/blog-pic-repo@master/uPic/a1SIyy.png#center) ### 3. extroot扩容 板载的存储空间一般比较小，能够安装ipk的空间一般也就剩余几M到十几M，但是大多数都支持sd卡或插入U盘来扩容。 为了为下一步的安装v2ray-core这种比较大的文件做准备，这里我插入了一张8G的SD卡来扩展根分区的空间。 openwrt支持`pivot-overlay`或者`pivot-root`两种方式扩充，具体原理不是很明白，但大意是第一种扩充`overlay`分区， opkg会将软件包安装在这个目录下，第二种则是干脆利落扩充根分区。这两种方式都尝试了一下，但是采用`pivot-overlay` 的方式扩充之后又一次导致无法开机只能重新烧rom，所以在这里还是比较推荐扩充根分区的第二种方式。 具体的步骤推荐看这篇文章：https://www.solarck.com/openwrt-extroot.html 这里也再贴一下做个记录： 1. 安装必要的包： ```shell opkg update opkg install e2fsprogs kmod-usb-core kmod-usb2 kmod-usb-storage usbutils kmod-fs-ext4 block-mount 如果是SD卡需要额外
opkg install fdisk 查看是否正确识别设备：  lsusb 或 fdisk -l 格式化设备：  mkfs.</description>
    </item>
    
    <item>
      <title>我的实习心得和秋招记录</title>
      <link>https://chongg039.cn/post/internship-and-application-record/</link>
      <pubDate>Tue, 29 Sep 2020 17:19:17 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/internship-and-application-record/</guid>
      <description>今年三月因为疫情的原因不能返校，对我们这些原本需要回校科研，不能实习的孩子来说反而成了一次机会。
从二月底我便开始了自己的春招实习过程。那时候可以用“一穷二白”来形容我的状态：leetcode只刷了七十多道，专业知识也都是临阵磨枪的状态。但那个时候我也是比较头铁，没有从一些小厂开始练兵，而是直接就找上互联网大厂。
我的第一个面试是钉钉，投的C++，却来了一个做客户端的面试官。面试官说明来历后，问我需不需要转给其他组，我内心的想的是反正都是为了锻炼积累经验，来谁都一样，就让面试官直接开始了。结果显而易见，我连map和hashmap底层的区别都答不上来……，我的第一次面试也就只短命的活了15分钟。
痛定思痛，我开始了从面试中思考问题的过程。应该说我的面试经历都是这样：被问到问题-&amp;gt;不会-&amp;gt;查找答案-&amp;gt;巩固。这种方法的好处就是可以从实战中快速积累经验，缺点也很明显，如果答的不好一次机会也就被浪费掉了，对方也不会给你下一次面试的机会。我铤而走险走了第一条路，也很幸运地没有在这条路上一直失败下去。
我春招投递的第二家公司还是阿里，但是是阿里云的存储团队。这个团队是我在本科时期就听说过的，也抱有一点朝圣的心理。我在阿里云的面试持续了整整七轮，将近两个月左右，时间跨度非常大，而且每次面试几乎都是高强度的一个小时以上，确实非常锻炼人。整体下来有一些磕磕绊绊，但还算顺利，几位面试官师兄给我的感觉非常好。可以这么说，阿里云的面试带给了我秋招都不能带来的强度感受，让我能够应对各种面试场合都拥有一颗平常心。最后我也是选择了阿里云作为我的实习选择，之后再详细说明。
除此之外，我还参加了腾讯和字节的春招面试。其实最开始我最想去的是腾讯，不仅仅是专业语言契合，也非常想去见识一下国内最强的产品团队-微信内部的一个工作状态。为了达到这个目的，我首先面试、竞聘了腾讯校园大使，掌握了第一手的招聘信息。而且那时我的阿里流程已过大半，经验、状态都处于最佳，便果断在四月面试了腾讯最难的部门WXG。有点遗憾的是，前三面过五关斩六将，顺风顺水，却不小心栽在了最后一面，犯了一个非常低级的错误，也算是为我的自负交了学费。所以不论是走到面试的哪一步，一定要注意问题的回顾和积累，切记不要放松了警惕。至于字节，投递的是我很感兴趣的搜索团队，结果二面之后没有动静，也就不提了。
整体看下来，我的春招只投递了三家大厂，而且都还比较具有挑战性。我的个人经验是既不要妄自菲薄，也不能夜郎自大，保有一颗平常心，注重每次面试的回顾和积累，多刷面经，一定会有好的结果。面对失利心理上失衡是正常的，但不要因为这次失利影响到下一次自己的状态。
在拿到阿里的实习offer之后，我在今年的5月21远程入职，并于28号动身前往杭州。说来也巧，上次来杭州还是2010年的世博会期间，那时候还在上初中，正好又是一个十年。这座城市并没有带给我多么美好的印象，她的美食、交通、气候都远远比不上成都，但我庆幸的是遇到了一群对的人。EBS的几位老哥不论是在工作、生活上都非常照顾我，给了我非常棒的“游戏体验”。我们一起打球、一起健身、一起探店、一起在东极岛上“撩妹”，就像在学校的师兄一样。都说阿里像一座大学，我用切身的体验感受到了确实如此。
说到技术的成长，工作强度肯定是有的，但是因为存储是阿里云发展了多年的重要基础支撑，所以一般双休是完全可以保证的，在现在的互联网行业中双休是非常诱人的企业保证。在我看来，阿里的管理属于“内松外紧”的状态，规定非常严格，但是内部却比较自由。刚到阿里我觉得寸步难行，什么东西都需要老板审批，但是从另一个角度来说“钉”老板也是很爽的，大家交流起来也能感受到逐渐扁平化的管理制度带来的优势。企业文档、团队文档非常完善，我觉得以阿里的体量来看，再也没有别的公司能找到比阿里更完善的文档和新人培养制度了。
做技术我本人是非常反感做CRUD这些工作的，但是在大数据的背景下这却是很多工作必不可少的内容。在阿里云的工作经历让我能够接触到国内乃至世界上最顶尖的云计算服务的各种实现，也就是俗话说的各种“高大上”的工作内容。以阿里云作为学校到工作的第一家转换的公司我个人觉得在合适不过了，不需要一开始便只能接触到“搬砖”一样的工作内容，反而能够学习到非常非常多的东西。所以如果你能够选择做有意义的事情，或者接触到行业顶尖的团队，那不妨认真考虑一下。
我实习的内容，尽管没有分布式的实现，但也很幸运地从0到1完成了一个内部的项目，对我个人的成长也是非常大的。当你看到你的工作从架构设计到一步一步成型，最后得到大家的认可，内心会充满自豪感。插一句题外话，我分配了一台redhat5作为开发机，用了三个月没有补全命令的vim，所有代码都是一个字符一个字符手敲出来的，这也让我成长很大……
学校8月底要开学，我也就那时候参加完了转正答辩回到了学校。最近几天收到了转正通过的意向书，不出意外明年是会回去的。除此之外我手里还有个字节的意向书，是在我实习的时候抽时间面试的。那时候和字节那边的一个大leader聊得比较投机，所以过得也比较顺利。回到学校后我又投了一下WXG，面试了两个小时却得知对方并不是微信的核心部门，遂也没有太大的兴趣继续面试下去了。
可以说我都没有进行正儿八经的秋招，所以也没法写一篇合格的面经出来。不过我经常用我在实习期间学到的经验帮同学们复盘他们自己的问题。在我看来，专业知识固然重要，但对面也会非常关注面试者概括问题和抽象问题的能力。如果你能把一个事情用非常简单的眼光剖析呈现出来，而不是在长篇大论随意发散，是非常加分的。除此之外，需要适当“包装”下你自己，能够一瞬间让面试官对你产生兴趣，而后能表现得从容不迫、侃侃而谈，也会成为你的优势。
我的秋招可以说是结束了，但我的学生时代还未完结。最后这一段时间的缓冲我希望能够好好利用起来，总结一些事情、学习一些新的东西。我的缓冲期要比别人长一些，应给能够更好地做一个心态上的转变。如果看到这里的你也是和我一样的心境，希望你能从我的教训中得到一些东西。共勉。</description>
    </item>
    
    <item>
      <title>2020 钱江有感</title>
      <link>https://chongg039.cn/post/2020-hangzhou-feeling/</link>
      <pubDate>Sat, 30 May 2020 20:57:03 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/2020-hangzhou-feeling/</guid>
      <description>现在的一个最大的感受就是，今年的疫情不仅仅是对社会，也对每个人产生了或多或少的影响。
缅怀我亲爱的梁师兄。我刚进实验室时便与他共事，一起训练模型，一起修改论文，也常常一起去华西开会、做实验。 相处的时间更长一些，自然我对他的感情会比我们这届其他人更多一些。
梁师兄是一个有着幽默精神的人，他也许并不是多么的兴趣高雅，不如说他就是像我一样的一个普普通通的学生， 也会有一些平常人都会有的“低级趣味”的娱乐活动。不过师兄与我不同的是，他常常能在某些事情上更加出类拔萃一些。
梁师兄喜欢打篮球和台球，这倒是与我的爱好惊奇其重叠。梁师兄个不高，可一手飘逸的后仰跳投时常成为众人关注的焦点。自然他的偶像就是科比了。让人唏嘘的是，师兄的最近一条朋友圈便是在纪念科比。不知如今二人是否进行过一些切磋呢。师兄台球打的也好，我、梁、单、董等一般会一周进行一次这项运动，其中单师兄既是梁师兄的舍友，也是我的老乡。二人球技都不错，只是球风稍有差别。单师兄偏技巧，观赏性高；梁师兄则是势大力沉，直捣黄龙。不过有时手感不佳，亦失其准度。
梁兄亦好网游，尤其擅长撸啊撸、吃鸡等竞技类游戏。尤其是吃鸡，由于本人有轻微的3D眩晕症状，又对此类游戏非常感兴趣，所以更加佩服吃鸡打的好的人。犹记得师兄带我们四排，一人独拿十余人头，而我等菜鸡只能跟在后面舔包，双击六六六的情形。
与梁师兄相处最多的时候，便是去华西做实验的时候，那也是我刚到实验室第一次接触到的项目之一。师兄带我认识了华西那边的同学和师长，带我调通了我的第一个神经网络模型，带我参与了他的论文的修改和编纂工作。师兄的论文是基于深度学习的基因优化方面的工作，和华西国家重点实验室合作了两年，也是马上要完成，准备投nature的，令人扼腕。
我自然是十分痛心的，也许是亦友亦师的不舍，也许是对意外发生在身边的一种不真实感。就像那句俗话说的，永远不会知道明天和意外哪个会先来。作为生者，我们对逝者的怀念是为了记住他们，让他们以另外一种形式活在这世上。而逝去的人对我们的提醒，则将永远是珍惜当下，珍惜自己眼前的人。
要说的上的坏习惯的话，梁兄唯一的“爱好”也就是抽烟了，不过抽的也少，毕竟压力有些大也可以理解。他的身体事实上是好得很的，听他说之前的胃病也在这两年调理好了。所以当听到他出意外的消息，我的第一反应是不相信的。带有一点灰色幽默的话，我一度以为他当时是不是在玩什么真心话大冒险的游戏……
思绪纷乱，不说了。本来我是想在师兄的头七那天写一篇缅怀的文字，来纪念这位好朋友。但无奈当时实在是琐事颇多。今天是2020年5月31日，马上就是夏天了，疫情在国内也基本走向尾声（我个人臆断的）。如今我身在杭州，窗外就是绿水青山，睹物思人之情有感而发，遂敲下此时真实的感受。
今年的情形对我个人的影响也很大。首先是今年竟然在家里呆了五个月左右，印象中自我上高中以来就没这么享福过。第二则是能够有充分的时间准备专业知识，也很幸运地能够地现身杭州。今天也是我来飞天的第三天，星期六，没有上班，正在找住的地方。不过给我的印象很好，并没有外界传言的那么可怕，也多亏了几位和蔼可亲的师兄无微不至的帮助。三个月的时间，还是对自己的成长有一个小小的期待。
至于明天干什么的话，还是去园区吧，从一些自己能做的做起。
当然，热爱工作是必须的，但是也要恢复健身。身体，才是革命的本钱。
5月31日于杭州转塘。</description>
    </item>
    
    <item>
      <title>Logi M585 更换微动记录</title>
      <link>https://chongg039.cn/post/change-mouse-micro-switch/</link>
      <pubDate>Sun, 03 May 2020 10:29:04 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/change-mouse-micro-switch/</guid>
      <description>现在的主力鼠标是 Logi 家最便宜的支持 Flow 的 M585 ，但是前一段时间左键开始双击了。于是便想着把里面坏掉的微动换一下。 Logi Options 支持切换左右键，在到货前可以将就用用。
和 Logi 家大部分鼠标一样，我这块 M585 左右两个微动都是欧姆龙国产的 D2FC-F-7N ，大概二十万次的寿命，批发大概一块一个左右的价格。既然要换，那就换个好点的吧，新买的是欧姆龙日产的 D2F-F-3-7 ，标称是 2000-3000 万次的寿命。这里就不打广告了，马云家关键字搜索就行，差不多都是八块一个左右的价格。
过程 M585 的拆解很方便，不像 G 系列的很多产品把螺丝藏在脚垫下面，只有接收器槽下面的一颗螺丝，然后将底盖向后面一推，就能抬开了，逐一有一根侧键连接线，打开的力度不要太的不然容易扯断。主板上一共三颗螺丝，也没有什么难度，卸掉就能把主板取下来了，大概就是下图这个样子：
然后准备好家伙，就把主板左侧两个原装微动焊接下来：
每个微动熔掉三个针脚的焊锡，再用吸锡器吸掉。注意要多吸几次，尽量完全吸干净，不然很难取下来。原有的焊锡本来就少，基本都在 PCB 的孔里面，而且还有些氧化了，弄了我好长时间，最后还是没弄干净最后一点，暴力拆下来的：
效果还可以。。。然后就将新买的微动装上去，注意不要前后装反了：
这里一个小插曲差点让我功亏一篑，上图左侧中间那个针脚，我在捅进来的时候不小心把 PCB 上面蚀刻的电路线给弄翘起来了，此时已经焊完最上面的那个引脚了，微动也取不下来，只能先把中间的引脚掰弯，然后再把敲起来的电路线塞回去。。。中间引脚就是因为这个原因多给了一点焊锡，绝对不是因为我的焊接技术太烂的原因。。。
还有一个需要注意的地方，能看到 PCB 三个引脚接孔两个是圆形的，最下方那个是方形的。之前查阅一些资料，有人说这个方形的孔不焊也行，后面再需要更换的话也方便拆卸。不知道不同的 PCB 有没有要求，我就先不焊了，这样试试。
最后原样组装回去，先给电试一下：
成了！那个方形引脚我也不焊了，套壳：
感受 这个新的微动，确实回弹力度更舒服，更清脆一些，也没有双击问题了。第一次换微动就成功了，比较幸运没有烧坏别的器件。唯一美中不足的就是在打扫卫生的时候，不小心碰掉了鼠标，导致左侧两个侧键中的其中一个不回弹了，扒开看了看不太好弄，不过也能正常使用就是了。
最后再放一张暴力拆解下来的原装微动的尸体：</description>
    </item>
    
    <item>
      <title>一些有意思的知识点整理</title>
      <link>https://chongg039.cn/post/some-interesting-konwledges/</link>
      <pubDate>Thu, 12 Mar 2020 16:02:41 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/some-interesting-konwledges/</guid>
      <description>一致性哈希算法 背景：有n个服务器做缓存，负载均衡的做法。
答：hash，对用户的序列（如IP）取n模，分发到对应的服务器上；
问：此时有一台宕机，或是业务需要新增了服务器，此时大多数用户的请求都会转到其他服务器，这样会发生大量访问错误，有没有办法。
思考：还是用hash，但需要像一个保证在增加和删除哈希模值时不会发生变化的情况，或发生了变化但可以纠正。
答：比如宕机一台，剩余n-1，首先还是模n，若分发的服务器不是宕机的服务器则不需要变动；若是，再对n-1取模，分发到任意一台完好的服务器中。若宕机m台，依照该思路每次减一求模直到n-m。 （但是对增加新的服务器，这种方式不是很好）
有没有更好的办法：一致性哈希，基本思路就是将服务器和用户请求散列到一个相同的区间上，使用相同的hash算法，因为hash的特殊作用可以把它想象成一个首尾相接的环。将散列后的用户顺时针查找第一个遇到的服务器作为对应的服务器，这样当环上增加或减少某个服务器节点，影响的将是有限个用户，并可以找到新的对应分配的服务器。
保证一致性哈希算法的平衡性，需要使用虚拟节点技术。
建议阅读博客。
BitMap算法 减少数据存放的占用内存大小的方式。考虑一个4字节int数值，也就是32bit，当有10000000个int会占用
4*10000000/1024/1024=38MB
若一个字节，占8bit，每个bit位用来标识下标数字是否存在，共需要
10000000/8/1024/1024=1.2MB
BitMap适合处理大量数据的加载、排序（鸽巢）和查询，缺点是无法对存在重复的数据进行排序和查找。做到这个需要建立一个十进制到二进制bit位的映射。
假设需要排序或者查找的总数N=10000000，那么我们需要申请的内存空间为 int a[N/32 + 1]。其中a[0]在内存中占32位：
a[0] ------&amp;gt; 0 - 31 a[1] ------&amp;gt; 32 - 63 a[2] ------&amp;gt; 64 - 95 a[3] ------&amp;gt; 96 - 127 ... 需要以下转换：
 求十进制数 0-N 对应的在数组 a 中的下标。index_loc = N / 32即可，index_loc即为n对应的数组下标。例如n = 76，则loc = 76 / 32 = 2，因此76在a[2]中； 求十进制数 0-N 对应的bit位。bit_loc = N % 32即可，例如 n = 76，bit_loc = 76 % 32 = 12； 利用移位 0-31 使得对应的 32bit 位为 1 。  建议阅读博客。</description>
    </item>
    
    <item>
      <title>TopK问题以及在海量数据下的情况</title>
      <link>https://chongg039.cn/post/top-k/</link>
      <pubDate>Wed, 11 Mar 2020 19:07:14 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/top-k/</guid>
      <description>解释：简单来说就是在一堆数据里面找到前 K 大（当然也可以是前 K 小）的数。
一般做法   排序，快排，然后取对应下标一侧的数据。数据量大时排序慢，而且不一定需要排序所有的。
  改进版，冒泡，只需要冒前K个，将全局排序优化为局部排序，但是仍需要排序。
  快排的另一种转换思路：如果一次排序的中间值等于K（类似寻找统计学中位数的问题），一侧就是TopK的数据。如果不等于只需要在一侧递归寻找即可。缺点是需要将数据一次载入内存，并且需要修改数组内容。
  上面的方法也叫“随机选择”。注意，这种方法是经典的“减治法”，和分治法不同的是减治法只需要求解一个子问题便可解决大问题，分治法需要解决所有的小问题才可以解决大问题。因此减治法时间复杂度是O(logn)，分治法则是O(nlogn)； 分治法，大问题分解为小问题，小问题都要递归各个分支，例如：快速排序 减治法，大问题分解为小问题，小问题只要递归一个分支，例如：二分查找，随机选择 经典解法：若找TopK大，维护一个大小为K的小顶堆，依次将数据放入堆中，当堆的大小满了的时候，只需要将堆顶元素与下一个数比较：如果大于堆顶元素，则将当前的堆顶元素抛弃，并将该元素插入堆中，调整堆（这一步带来开销）。遍历完全部数据，Top K 的元素也自然都在堆里面了。这种方式同样适合海量数据，不需要将数据一次加载完毕，可以一次只取一部分，因为我们只需要将数据一个个拿来与堆顶比较。时间复杂度是：遍历全部数据是O(n)，每次和堆顶比较若产生调整则为O(logk)，共O(nlogk)。当k足够小，可视作O(n)。建堆时间复杂度为O(k)，可视作常数，注意建堆时间不是O(klogk)，因为是自底向上，具体可看推导。  海量数据处理   分布式思想：将数据分散在多台机器中，然后每台机器并行计算各自的 TopK 数据，最后汇总，再计算得到最终的 TopK 数据。
  40亿个数，查找某个数字是不是在里面。所需内存
  40 * 10 ^ 8 * 4B(int大小) = 16G 方法一：bitmap，当然可以同时使用布隆过滤器；
方法二：将这么多的数据分成许多块， 比如每一个块的大小是1000，那么第一块保存的就是0到999的数，第2块保存的就是1000 到1999的数……实际上我们并不保存这些数，而是给每一个块设置一个计数器。 这样每读入一个数，我们就在它所在的块对应的计数器加1。处理结束之后， 我们找到一个块，它的计数器值小于块大小(1000)， 说明了这一段里面一定有数字是文件中所不包含的。然后我们单独处理这个块即可。
TopK终极思路 特定的统计方式+堆，统计方式主要是hashmap，对单词的话可以采用Trie树。然后再维护一个大小为K的小顶堆。</description>
    </item>
    
    <item>
      <title>STL中的map与hash_map</title>
      <link>https://chongg039.cn/post/map_vs_hashmap/</link>
      <pubDate>Fri, 06 Mar 2020 16:41:17 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/map_vs_hashmap/</guid>
      <description>阅读STL源码有感，加上有个面试官问过这个问题没回答好，做下记录。
区别 hash_map是基于哈希表的键值存储实现，STL中的map是基于红黑树实现的。对于set和hash_set是一样的，因此可以将其看作哈希表和红黑树的区别。
SGI STL中不提供hash_map和hash_set的接口，但允许编译器厂商进行扩展，这就导致实现比较混乱。因此C++11提供了正式的关联式容器unordered_map和unordered_set。不过为了方便记忆，我们还是用hash_map来称呼，比较直观。
map 先说下map，底层实现是RB-Tree，一种不同于AVL树的平衡二叉（搜索）树的实现。我们先不看各种树的实现，先看红黑树的特点。
既然红黑树也是一种二叉搜索树，说明内部是自动排序的，对于一个非叶子节点，左子节点总比它小，右子节点总比他大，那么在红黑树实现的map中查找元素也就是O(logN)级别，因为树的深度就是O(logN)。对于插入和删除，都需要调整红黑树使它继续满足平衡二叉搜索树的条件，因此时间复杂度也是O(logN)。
对于内存空间占用，红黑树要小一点，因为只需要为存在的节点分配空间即可，也很显然具备更好地伸缩性。
对于红黑树实现的map，树中的节点存放的是一个std::pair，第一个元素视作红黑树排序的依据（即map的key），第二个元素是map的value。
hash_map 再看hash_map，由一个固定长度的连续空间（一般是数组）和一组hash算法组成。hash又名散列，把任意长度的输入转换为固定长度的输出，这个输出的长度一般远小于输入的空间长度，可以认为是一种压缩映射。
很显然hash的查找速度是一种O(1)级别的查找，通过数组的下标直接定址到相应的空间取出value，当然这是一种很理想的情况，等下还要说到。插入和删除也是常数级别，单从时间复杂度上来讲，哈希表的速度是要优于红黑树的，查找速度也和数据量无关。不过也不尽然，因为hash函数的计算也需要时间，而且如果产生冲突又需要额外的耗时。当然，如果你的内存足够，数据也足够静态，不怎么需要动态扩增，hash是一种更好的选择。
很显然hash_map是无序的，且需要事先分配足够的内存空间。
红黑树 翻到一篇博客，图文并茂，非常详细，链接。
哈希冲突解决  开放定址法：从发生冲突的单元开始，按照一定的次序找到下一个空闲单元存入。这种方法表长一定要大于等于要存放的元素个数，缺点是删除的时候不能真正删除，只能给一个标识，等下次有元素插入该地址时再删除，否则会引起查找错误。方法有三种：线性探测再散列、二次探测再散列等； 链地址法：对发生冲突的哈希值相同的元素，将他们构成一个单链表，并将链表的头指针存放在哈希表的对应单元中，对哈希表的查找、删除和添加主要发生在对应的链表中，适用于经常需要插入和删除的情况； 再哈希法：就是构造多个不同的哈希函数，产生冲突时再使用下一个哈希函数计算要存放的地址，不容易产生冲突，但是增加了计算时间； 建立公共溢出区：将哈希表分为公共表和溢出表，发生溢出时将所有溢出数据统一存放溢出区。  </description>
    </item>
    
    <item>
      <title>[设计模式系列]迭代器模式与解释器模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-11/</link>
      <pubDate>Fri, 28 Feb 2020 09:33:01 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-11/</guid>
      <description>来看下行为模式的最后两个部分。
迭代器模式(Iterator Pattern) STL里面的迭代器就是这个。迭代器模式主要就是为了解决对一个聚合对象的遍历问题，将遍历行为封装到一个类型中，避免了过度暴露聚合类内部表示。
来看下Wikipedia上的UML图：
class Iterator; // 聚合对象 class Aggregate { public: virtual ~Aggregate() = default; virtual Iterator *CreateIterator() = 0; virtual int GetSize() const = 0; virtual int GetItem(int idx) const = 0; }; class ConcreteAggregate : public Aggregate { public: explicit ConcreteAggregate(std::vector&amp;lt;int&amp;gt; nums); Iterator *CreateIterator() override; int GetSize() const override; int GetItem(int idx) const override; private: std::vector&amp;lt;int&amp;gt; nums_; }; // 迭代器抽象类 class Iterator { public: virtual ~Iterator() = default; virtual bool HasNext() = 0; virtual void Next() = 0; virtual int operator*() = 0; }; class ConcreteIterator : public Iterator { public: explicit ConcreteIterator(Aggregate *aggregate, int idx = 0); bool HasNext() override; void Next() override; int operator*() override; private: Aggregate *aggregate_; int idx_; }; ConcreteAggregate::ConcreteAggregate(std::vector&amp;lt;int&amp;gt; nums) : nums_(std::move(nums)) {} Iterator *ConcreteAggregate::CreateIterator() { return new ConcreteIterator(this); } int ConcreteAggregate::GetSize() const { return nums_.</description>
    </item>
    
    <item>
      <title>[设计模式系列]命令模式与访问者模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-10/</link>
      <pubDate>Thu, 27 Feb 2020 09:08:40 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-10/</guid>
      <description>命令模式和访问者模式也是两种常见的行为模式。
命令模式(Command Pattern) Command模式结构图中，将请求的接收者（处理者）放到Command的具体子类ConcreteCommand中，当请求到来时（Invoker发出Notify消息激活 Command对象），ConcreteCommand将处理请求交给Receiver对象进行处理。
// 具体的接收人 class Receiver { public: void Action(); }; // 抽象类 class Command { public: virtual ~Command() = default; virtual void set_receiver(Receiver *receiver) = 0; virtual void Execute() = 0; }; class ConcreteCommand : public Command { public: void set_receiver(Receiver *receiver) override; void Execute() override; private: Receiver *receiver_; }; class Invoker { public: void set_command(Command *command); void Notify(); private: std::list&amp;lt;Command *&amp;gt; commands_; }; void Receiver::Action() { std::cout &amp;lt;&amp;lt; &amp;#34;receiver do action.</description>
    </item>
    
    <item>
      <title>[设计模式系列]备忘录模式与中介者模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-9/</link>
      <pubDate>Wed, 26 Feb 2020 19:44:52 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-9/</guid>
      <description>闲话少说直接进入正题。
备忘录模式(Memento Pattern) 备忘录模式就是可以维护一个对象的内部状态，并在对象的外部保存这个状态。这样就可以随时将对象恢复成保存的那个状态，就像吃后悔药一样，属于一个&amp;quot;undo&amp;quot;操作。
看下UML图，来源：
class Memento { public: explicit Memento(std::string state); const std::string &amp;amp;get_state() const; void set_state(const std::string &amp;amp;state); private: std::string state_; }; // 管理者 class Caretaker { public: ~Caretaker(); public: Memento *get_memento() const; void set_memento(Memento *memento); private: Memento *memento_; }; // 发起人 class Originator { public: const std::string &amp;amp;get_state() const; void set_state(const std::string &amp;amp;state); Memento *CreateMemento(); void SetMemento(Memento *memento); void Show(); private: std::string state_; }; Memento::Memento(std::string state) : state_(std::move(state)) {} const std::string &amp;amp;Memento::get_state() const { return state_; } void Memento::set_state(const std::string &amp;amp;state) { state_ = state; } Caretaker::~Caretaker() { if (memento_) { delete memento_; memento_ = nullptr; } } Memento *Caretaker::get_memento() const { return memento_; } void Caretaker::set_memento(Memento *memento) { memento_ = memento; } const std::string &amp;amp;Originator::get_state() const { return state_; } void Originator::set_state(const std::string &amp;amp;state) { state_ = state; } Memento *Originator::CreateMemento() { return new Memento(state_); } void Originator::SetMemento(Memento *memento) { state_ = memento-&amp;gt;get_state(); } void Originator::Show() { std::cout &amp;lt;&amp;lt; &amp;#34;state is: &amp;#34; &amp;lt;&amp;lt; state_ &amp;lt;&amp;lt; std::endl; } 看下效果：</description>
    </item>
    
    <item>
      <title>[设计模式系列]模板模式、状态模式与观察者模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-8/</link>
      <pubDate>Tue, 25 Feb 2020 10:22:41 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-8/</guid>
      <description>模板模式(Template Pattern) 模板模式类似策略模式，都是将算法接口定义在抽象类中，具体的实现细节交给派生类去做。但是策略模式偏重组合，模板模式侧重继承。模板方法模式将重复的代码交给了父类，各自的子类只负责算法不同的细节部分。
class Abstract { public: virtual ~Abstract() = default; void TemplateMethod(); protected: virtual void Method1() = 0; virtual void Method2() = 0; }; class ConcreteA : public Abstract { public: void Method1() override; void Method2() override; }; class ConcreteB : public Abstract { public: void Method1() override; void Method2() override; }; void Abstract::TemplateMethod() { Method1(); Method2(); } void ConcreteA::Method1() { std::cout &amp;lt;&amp;lt; &amp;#34;concrete A use method 1&amp;#34; &amp;lt;&amp;lt; std::endl; } void ConcreteA::Method2() { std::cout &amp;lt;&amp;lt; &amp;#34;concrete A use method 2&amp;#34; &amp;lt;&amp;lt; std::endl; } void ConcreteB::Method1() { std::cout &amp;lt;&amp;lt; &amp;#34;concrete B use method 1&amp;#34; &amp;lt;&amp;lt; std::endl; } void ConcreteB::Method2() { std::cout &amp;lt;&amp;lt; &amp;#34;concrete B use method 2&amp;#34; &amp;lt;&amp;lt; std::endl; } 状态模式(State Pattern) 有限状态自动机就是这样一个案例，对不同的状态执行不同的动作。一个很典型的就是switch/case语句，但switch/case没有实现状态逻辑和动作的分离，导致若条件很多时将会维护很冗长且复杂的代码。</description>
    </item>
    
    <item>
      <title>[设计模式系列]职责链模式与策略模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-7/</link>
      <pubDate>Mon, 24 Feb 2020 17:12:56 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-7/</guid>
      <description>进入GOF中的最后一部分，行为模式。
职责链模式(Chain-of-Responsibility Pattern) 职责链模式也不难理解，就是用户提交一个请求，允许这个请求沿着一条多个具体行为对象组成的链流动，直到有某个对象处理后（或是一个最终的处理对象处理完成）返回对应的结果，用户并不知道是哪个具体的行为人处理的，用户也不需要关心这个。考虑到这个层面，所有的行为对象应该继承一个公有的接口类：
class Handler { public: virtual ~Handler() = default; virtual void HandleRequest(int request) = 0; // 设置继任者  void SetSuccessor(std::shared_ptr&amp;lt;Handler&amp;gt; successor); protected: std::shared_ptr&amp;lt;Handler&amp;gt; successor_; }; class ConcreteA : public Handler { public: void HandleRequest(int request) override; }; class ConcreteB : public Handler { public: void HandleRequest(int request) override; }; class DefaultConcrete : public Handler { public: void HandleRequest(int request) override; }; void Handler::SetSuccessor(std::shared_ptr&amp;lt;Handler&amp;gt; successor) { successor_ = std::move(successor); } void ConcreteA::HandleRequest(int request) { if (1 == request) { std::cout &amp;lt;&amp;lt; &amp;#34;concrete A handle something&amp;#34; &amp;lt;&amp;lt; std::endl; } else if (successor_) { successor_-&amp;gt;HandleRequest(request); } } void ConcreteB::HandleRequest(int request) { if (2 == request) { std::cout &amp;lt;&amp;lt; &amp;#34;concrete B handle something&amp;#34; &amp;lt;&amp;lt; std::endl; } else if (successor_) { successor_-&amp;gt;HandleRequest(request); } } void DefaultConcrete::HandleRequest(int request) { std::cout &amp;lt;&amp;lt; &amp;#34;default concrete final handle something&amp;#34; &amp;lt;&amp;lt; std::endl; } 设置了两个处理实例和一个默认处理实例，将它们连接起来：</description>
    </item>
    
    <item>
      <title>[设计模式系列]享元模式、外观模式与代理模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-6/</link>
      <pubDate>Sun, 23 Feb 2020 09:30:35 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-6/</guid>
      <description>不多啰嗦直奔主题，来看下GOF中结构型模式的最后三部分。
享元模式(Flyweight Pattern) 过多的对象创建会造成很大的存储开销，而这其中有相当一部分可能是重复且不必要的。因此对于一个特定的对象我们可以将其分为”内部状态“和”外部状态“两部分。内部状态指可以被共享的、一般不会变化的状态，存储在类的内部；对于可能产生变化的外部状态，我们选择将其作为参数传递给对象。
享元模式类似工厂模式，有一个工厂对象，这个工厂用于接收用户的每一次申请对象的请求。工厂内部有一个维护了所有对象的”仓库“。每一次会先检查这个仓库中是否存在了这个对象。若存在便返回，若不存在，就创建一个新的对象返回，并将其添加进这个仓库中。
class Flyweight; // 工厂对象 class FlyweightFactory { public: FlyweightFactory(); ~FlyweightFactory(); Flyweight *GetFlyweight(const std::string &amp;amp;key); private: std::map&amp;lt;std::string, Flyweight *&amp;gt; store_; }; class Flyweight { public: virtual ~Flyweight() = default; virtual void Operation(int extrinsic_state) = 0; }; class ConcreteFlyweight : public Flyweight { public: void Operation(int extrinsic_state) override; }; class UnShareConcreteFlyweight : public Flyweight { public: void Operation(int extrinsic_state) override; }; FlyweightFactory::FlyweightFactory() = default; FlyweightFactory::~FlyweightFactory() = default; Flyweight *FlyweightFactory::GetFlyweight(const std::string &amp;amp;key) { if (store_.</description>
    </item>
    
    <item>
      <title>[设计模式系列]装饰模式与组合模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-5/</link>
      <pubDate>Sat, 22 Feb 2020 11:01:40 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-5/</guid>
      <description>这篇来学习一下装饰模式与组合模式，也是结构型模式中的内容。
装饰模式(Decorator Pattern) 顾名思义，装饰模式就是往一个现有的产品上添加功能部件，增加一些新的额外职责，将这个被嵌入的对象称为职责。注意这不是对所有的类都进行添加，而是对某些实例化的对象进行添加。并且，所有的装饰应该继承同一个装饰接口。
与Bridge模式很相似，侧重的也是单一职责与组合代替继承。考虑和之前相同的例子，对于题干Stem和解题过程，可以将抽取实体和关系的行为与其分离，作为行为装饰在具体的对象中。
// sentence基类，将装饰行为与其分离 class Sentence { public: virtual ~Sentence() = default; virtual void ShowDecorate() = 0; }; // stem子类实例 class Stem : public Sentence { public: void ShowDecorate() override; }; // solution子类实例 class Solution : public Sentence { public: void ShowDecorate() override; }; // 装饰行为基类 class Decorator : public Sentence { public: explicit Decorator(Sentence *sentence); ~Decorator() override; void ShowDecorate() override; private: Sentence *sentence_; }; // 装饰类EntityDecorator class EntityDecorator : public Decorator { public: explicit EntityDecorator(Sentence *sentence); void ShowDecorate() override; private: void ExtractEntity(); }; // 装饰类RelationDecorator class RelationDecorator : public Decorator { public: explicit RelationDecorator(Sentence *sentence); void ShowDecorate() override; private: void ExtractRelation(); }; void Stem::ShowDecorate() { std::cout &amp;lt;&amp;lt; &amp;#34;stem&amp;#39;s decorator&amp;#34; &amp;lt;&amp;lt; std::endl; } void Solution::ShowDecorate() { std::cout &amp;lt;&amp;lt; &amp;#34;solution&amp;#39;s decorator&amp;#34; &amp;lt;&amp;lt; std::endl; } Decorator::Decorator(Sentence *sentence) : sentence_(sentence) {} Decorator::~Decorator() { if (sentence_) { delete sentence_; sentence_ = nullptr; } } void Decorator::ShowDecorate() { sentence_-&amp;gt;ShowDecorate(); } EntityDecorator::EntityDecorator(Sentence *sentence) : Decorator(sentence) {} void EntityDecorator::ShowDecorate() { Decorator::ShowDecorate(); ExtractEntity(); } void EntityDecorator::ExtractEntity() { std::cout &amp;lt;&amp;lt; &amp;#34;extract some entities&amp;#34; &amp;lt;&amp;lt; std::endl; } RelationDecorator::RelationDecorator(Sentence *sentence) : Decorator(sentence) {} void RelationDecorator::ShowDecorate() { Decorator::ShowDecorate(); ExtractRelation(); } void RelationDecorator::ExtractRelation() { std::cout &amp;lt;&amp;lt; &amp;#34;extract some relations&amp;#34; &amp;lt;&amp;lt; std::endl; } 注意装饰器基类要继承Sentence接口的方法，现在我们的程序就可以这么写：</description>
    </item>
    
    <item>
      <title>[设计模式系列]桥接模式与适配器模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-4/</link>
      <pubDate>Fri, 21 Feb 2020 21:04:39 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-4/</guid>
      <description>这篇文章进入GOF中的结构型模式篇幅。
Bridge模式 桥接模式号称设计模式中最难理解的模式，同时用好了能够很大程度上降低模块之间的耦合程度。因为本质上桥接模式实现了抽象化(Abstraction)与实现化(Implementation)的解耦，将继承关系转变为了组合关系，减少了代码编写量。
说得通俗一点，就是一个实现中若涉及多个不同层次的继承关系，如果不将其合理解耦，则会产生很多设计上冗余的代码。cabinriver写的这篇文章中举了一个非常棒的例子，我也暂时没有想到更合适的，就在这里重复一下，方便学习记录。感谢他的工作。
一台电脑可能有不同的制造商，每台电脑又可以安装多种不同的操作系统。电脑上在生产一台电脑时，需要生产出安装了不同操作系统的电脑。那么我们就应该将操作系统这个继承体系分离出去：
// 操作系统 class OS { public: virtual ~OS() = default; virtual void Run() = 0; }; class Linux : public OS { public: void Run() override; }; class Windows : public OS { public: void Run() override; }; // 不同品牌的电脑 class Computer { public: virtual ~Computer() = default; virtual void Install(OS *os) = 0; }; class Dell : public Computer { public: void Install(OS *os) override; }; class Apple : public Computer { public: void Install(OS *os) override; }; void Linux::Run() { std::cout &amp;lt;&amp;lt; &amp;#34;Linux running.</description>
    </item>
    
    <item>
      <title>[基础知识]计算机网络</title>
      <link>https://chongg039.cn/post/network-base/</link>
      <pubDate>Thu, 20 Feb 2020 20:32:59 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/network-base/</guid>
      <description>TCP拥塞控制：慢开始、拥塞避免、快重传、快恢复 建议阅读博客。
并发和线程 线程数是不是越大越好？ 肯定不是的，首先服务器的cpu核数有限，同时并发的线程数是有限的，1核cpu设置10000个工作线程是没有意义的；线程的切换是有开销的，如果线程切换过于频繁，反而使性能降低。
调用sleep()函数的时候，线程是否一直占用cpu？ 不占用，等待时会把cpu让出来，给其他需要cpu资源的线程使用，不止sleep()函数，在进行一些阻塞调用，例如网络编程中的阻塞accept()【等待客户端连接】和阻塞recv()【等待下游回包】也不占用cpu资源。
补充：sleep与wait方法的区别可以参见之前的一篇博客的介绍：http://blog.csdn.net/megustas_jjc/article/details/71304979
如果cpu是单核的，设置多线程有什么意义，能提高并发性能么？ 即使是单核，使用多线程也是有意义的
 多线程编码可以让我们的服务/代码更加清晰，有些IO线程收发包，有些Worker线程进行任务处理，有些Timeout线程进行超时检测 如果有一个任务一直占用CPU资源在进行计算，那么此时增加线程并不能增加并发，例如这样的一个代码while(1){ i++; }该代码一直不停的占用CPU资源进行计算，会使CPU占用率达到100% 通常来说，Worker线程一般不会一直占用CPU进行计算，此时即使CPU是单核，增加Worker线程也能够提高并发，因为这个线程在休息的时候，其他的线程可以继续工作  TCP序列号和确认号 TCP首部固定长度20字节，可选40字节，即最长60字节。
序列号占32位，即4字节，用来保证交付到的报文的顺序组合，因为可能不是顺序到达的。序号字段只有在下面两种情况的任意一种才有意义：
 数据字段至少包含一个字节 这是一个 SYN 段，或者是 FIN 段，或者是 RST 段。  每传送一个 TCP 段，都要等待对方回复一个确认。不过这种方式效率太低，在 TCP 协议中，一般采用累积确认的方式，即每传送多个连续 TCP 段，可以只对最后一个 TCP 段进行确认。
对方通过回复一个确认号，来表示确认已经接收到了哪个 TCP 段。比如发送方发送了一个报文段序号为 301 的 TCP 段，这个段携带了 100 字节数据，则接收方应当回复的确认号是 401，它表示接收方已经收到了字节序号为 [0, 400] 的数据，现在期望你发送字节序号为 401 以及以后的数据。
保障udp可靠性 UDP不属于连接协议，具有资源消耗少，处理速度快的优点，所以通常音频，视频和普通数据在传送时，使用UDP较多，因为即使丢失少量的包，也不会对接受结果产生较大的影响。
传输层无法保证数据的可靠传输，只能通过应用层来实现了。实现的方式可以参照tcp可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。
最简单的方式是在应用层模仿传输层TCP的可靠性传输。下面不考虑拥塞处理，可靠UDP的简单设计。
 添加seq/ack机制，确保数据发送到对端 添加发送和接收缓冲区，主要是用户超时重传。 添加超时重传机制。  详细说明：送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据。</description>
    </item>
    
    <item>
      <title>[基础知识]操作系统</title>
      <link>https://chongg039.cn/post/os-base/</link>
      <pubDate>Thu, 20 Feb 2020 20:32:11 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/os-base/</guid>
      <description>回顾和整理操作系统相关的知识点以及C++实现。
用户态与内核态 用户态与内核态是Linux的体系结构，也叫用户空间和内核空间，用户态是提供应用程序运行的空间，内核态就是控制计算机硬件运行的那部分特殊的软件运行的空间。用户态的程序想要访问这些硬件资源，内核态必须为之提供一组访问接口，这些接口就被称为系统调用(System Call)。
一般来讲，软件运行在用户态。但当程序需要调用操作系统提供的某一服务，如打开文件、连接设备、fork进程等，就需要切换至内核态，此时进程也就不进行相应的工作了，取而代之的是内核在进行某些处理。
中断是计算机在执行程序时，出现某些特殊的情况导致CPU暂停对指令的执行，转而去处理这项特殊的事务，处理完之后再回去处理先前的任务。中断一般有三类：
 由硬件异常或故障引起的内部异常中断； 由程序中的中断指令引起的软中断； 由外部设备请求引起的外部中断。  我们最为关心的是软中断。当一个进程发出一个系统调用的请求之后，会产生一个软中断，此时系统会对这个软中断进行处理，这样便从用户态切换到了内核态。理论上，这三种中断均可以从用户态切换到内核态。
进程、线程和协程 进程(process)是资源分配的基本单位，一般由代码块、数据区、堆、栈段组成。线程(thread)是CPU调度的基本单位，是进程的一个实体，可独立运行。一个进程一般由多个线程构成，且多个线程可以并发执行。
在同一个进程中，多个线程共享该进程的代码段（代码、常量）、数据段（全局变量、静态变量）和扩展段（堆存储），但拥有各自的栈段，用来存放所有的局部变量和临时变量、程序计数器、线程id和寄存器组中的值。
协程(coroutine)是一种轻量级的用户态的线程，与线程的特点基本一样，但避免了无意义的调度和内核切换的开销，但同时带来的是编写者需要自己承担调度协程的责任，且只能模拟多任务并发，无法使用多核CPU进行并行操作。
PCB与进程的创建 进程控制块(Process Control Block, PCB)是进程实体的一部分，是操作系统中最重要的记录型数据结构。PCB中记录了操作系统所需要的、用于描述进程情况及控制进程运行所需要的全部信息。主要包含以下四个部分：
 唯一标识一个进程的进程标识符，有外部标识符和内部标识符； 处理机状态信息； 进程调度信息； 进程控制信息。  系统按照以下流程创建进程：
 分配、初始化PCB； 初始化机器寄存器； 拷贝、初始化内存页表； 从硬盘加载程序代码到内存； 将进程添加至就绪队列； 进程调度时，选择该进程，切换至用户态开始执行该进程。  进程调度算法 操作系统通过进程调度算法快速切换进程，使得每个进程都有一定的时间片来响应用户提交的请求，基本的调度算法有：
FCFS先来先服务 简单，效率低，对长作业有利，对短作业不利；在CPU繁忙型作业上表现可以，不适用于IO繁忙型。
时间片轮转 还是先来先服务，但是每个进程只能运行一个预设的时间片，一个时间片内未完，该进程就必须被剥夺，释放处理器给下一个就绪的进程，并返回就绪队列的末尾等待下一次被调度。因此时间片的选取至关重要，过大退化为FCFS，过小则会频繁切换进程，增大处理器的时间开销导致真正服务于进程的时间变少。
SJF短作业优先 优先调度短作业，长作业可能会产生”饥饿“现象，同时也没有考虑到作业的紧迫程度。
优先级调度 分为剥夺式与非剥夺式：
 非剥夺式优先级调度指当某个进程正在CPU上运行时，有某个更为重要的进程进入了就绪队列，仍让当前进程继续运行，直到其由于自身原因让出处理器，再将处理器分配给更重要的那个进程； 剥夺式优先级调度是指当某个更为重要的进程进入就绪队列时，立即暂停正在运行的进程，将处理器分配给更重要的这个。  多级反馈队列(带优先级的时间片轮转) 算法思想：
 设置多个就绪队列，每个具有不同的优先级，第1级优先级最高，依次降低； 优先级越高的队列中时间片越短，不同就绪队列中时间片依次递增； 每个就绪队列中按照FCFS进行调度； 每次进来一个新的进程，放入第一级就绪队列，并等待调度； 若被调度的进程能够在时间片内执行完，就可从系统中撤离；若没有执行完，将其转入下一级就绪队列的末尾，排队等待调度； 当进程被转入最后一级优先级队列，按照时间片轮转进行调度； 调度程序从高优先级的就绪队列中开始调度，当且仅当该队列为空才从下一级队列开始调度； 若处理器正在执行某进程，又有新的进程添加到了优先级更高的就绪队列中，则立即抢占处理器，将正在执行的进程放入当前就绪队列的末尾，并将处理器分配给更高优先级的进程。  同步与通信 线程之间共享资源，但拥有各自不同的运行栈，进程之间互相隔离。线程并发需要解决的是同步问题，进程则需要解决通信问题。
线程同步 原子操作可以是一个步骤，也可以是按照某个顺序的多个步骤，但是不能被切割，具有整体性。一旦开始就必须执行到结束，中间不能被线程调度机制打断。原子操作是不需要同步的，需要线程同步的根本原因在于对普通变量的操作不是原子的。
涉及原子操作的关键字：synchronize、volatile、atomic。
每个进程中访问临界资源的那部分代码被称为临界区，是每次仅允许一个进程访问的共享资源。互斥访问临界资源一般可以通过信号量(semaphore)或互斥锁(mutex)进行。临界资源数量为1时信号量将退化为锁。
进程通信IPC 管道一般有无名管道和命名管道FIFO。无名管道是unix中IPC最古老的形式，一般由一个读文件描述符fd[0]和写文件描述符fd[1]组成，半双工，只能用于父子进程、兄弟进程之间的通信，是一种存在与内存中的特殊的文件系统。FIFO可以在无关进程之间交换数据，管道中先进先出，是一种文件类型，有路径名。</description>
    </item>
    
    <item>
      <title>[设计模式系列]建造者模式与原型模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-3/</link>
      <pubDate>Thu, 20 Feb 2020 10:32:08 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-3/</guid>
      <description>本篇再来学习一下GOF中提到的创建型模式的最后两种：建造者模式(Builder Pattern)和原型模式(Prototype Pattern)。
建造者模式(Builder Pattern) Builder模式的作用是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。和抽象工厂模式有类似之处，建造者模式也是用来创建大而复杂的对象，只不过更强调按照某种顺序一步步构建的这个过程，并且通过相同的创建过程可以获得不同的最终对象。
一般而言建造者模式由一个Builder基类和一个具体的Director类构成。与抽象工厂模式不同的另一点在于Builder一般不直接返回一个对象，只是规定了所有属性的接口和初始化顺序，具体的对象生成工作交由Director中的一个方法来完成。
考虑上篇文章那个例子，我们要为Stem、SubStem、Option和Solution生成要保存的信息，假设每个里面都需要按顺序初始化下面两个部分：
// InfoBuilder class InfoBuilder { public: virtual ~InfoBuilder() = default; // 构建Entity部分  virtual void BuildEntityPart() = 0; // 构建Relation部分  virtual void BuildRelationPart() = 0; }; // 题干信息Builder class StemInfoBuilder : public InfoBuilder { public: void BuildEntityPart() override; void BuildRelationPart() override; }; // 小问信息Builder class SubStemInfoBuilder : public InfoBuilder { public: void BuildEntityPart() override; void BuildRelationPart() override; }; // InfoDirector class InfoDirector { public: explicit InfoDirector(InfoBuilder *info_builder); ~InfoDirector(); void Construct(); private: InfoBuilder *info_builder_; }; void StemInfoBuilder::BuildEntityPart() { std::cout &amp;lt;&amp;lt; &amp;#34;now build entity part for stem&amp;#34; &amp;lt;&amp;lt; std::endl; } void StemInfoBuilder::BuildRelationPart() { std::cout &amp;lt;&amp;lt; &amp;#34;now build relation part for stem&amp;#34; &amp;lt;&amp;lt; std::endl; } void SubStemInfoBuilder::BuildEntityPart() { std::cout &amp;lt;&amp;lt; &amp;#34;now build entity part for sub_stem&amp;#34; &amp;lt;&amp;lt; std::endl; } void SubStemInfoBuilder::BuildRelationPart() { std::cout &amp;lt;&amp;lt; &amp;#34;now build relation part for sub_stem&amp;#34; &amp;lt;&amp;lt; std::endl; } InfoDirector::InfoDirector(InfoBuilder *info_builder) : info_builder_(info_builder) {} InfoDirector::~InfoDirector() { if (info_builder_) { delete info_builder_; info_builder_ = nullptr; } } void InfoDirector::Construct() { info_builder_-&amp;gt;BuildEntityPart(); info_builder_-&amp;gt;BuildRelationPart(); } 注意我这个析构函数使用了delete，也就是代表指针指向的一定是堆上new出来的资源，不能是构造出来的对象再取地址。即：</description>
    </item>
    
    <item>
      <title>[设计模式系列]工厂模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-2/</link>
      <pubDate>Wed, 19 Feb 2020 15:41:09 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-2/</guid>
      <description>这一节再来讨论一下工厂模式，主要分为三种：简单工厂模式、工厂方法模式和抽象工厂模式。其实说实话我觉得工厂模式比单例模式还要直观一点，因为这就是多态基类实例化子类的方式，自然而然就能想到。
考虑以下这个实例，一份完整的数学选择题应该会包含如下几个部分：
 题干部分(stem) 小问部分(sub_stem) 选项部分(option) 解答过程(solution)  在进行设计时，需要对这四个部分抽象出相同的特性。那么这四个部分不论怎么变化，首先都是“语句(sentence)”（这里并不是指字符串的意思）。那么我们就可以在Sentence基类的基础上讨论工厂方法的实现方式。
// 基类, 不能被实例化 class Sentence { public: virtual ~Sentence() = default; virtual void ShowMsg() = 0; }; // 题干 class Stem : public Sentence { public: void ShowMsg() override { std::cout &amp;lt;&amp;lt; &amp;#34;this is a stem&amp;#34; &amp;lt;&amp;lt; std::endl; }; }; // 小问 class SubStem : public Sentence { public: void ShowMsg() override { std::cout &amp;lt;&amp;lt; &amp;#34;this is a sub_stem&amp;#34; &amp;lt;&amp;lt; std::endl; }; }; // 选项 class Option : public Sentence { public: void ShowMsg() override { std::cout &amp;lt;&amp;lt; &amp;#34;this is an option&amp;#34; &amp;lt;&amp;lt; std::endl; }; }; // 解答过程 class Solution : public Sentence { public: void ShowMsg() override { std::cout &amp;lt;&amp;lt; &amp;#34;this is a solution&amp;#34; &amp;lt;&amp;lt; std::endl; }; }; 简单工厂模式(Simple Factory) 简单工厂模式就是多态，C++中基类的指针或引用都可以调用子类的虚函数达到多态的效果，看例子：</description>
    </item>
    
    <item>
      <title>[设计模式系列]单例模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-1/</link>
      <pubDate>Mon, 17 Feb 2020 17:01:20 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-1/</guid>
      <description>开一个新坑，记录一下设计模式的学习和使用经过。因为最近在写一个项目，首先接触到的和思考的就是单例模式，就从这里写起吧。
出发点 有时候不论是出于易用性考虑还是效率上的考虑，我们希望某些资源仅被初始化一次，但是其他所有的实例都可以使用它。大部分情况下这类资源是不会被改动的，当然也会有意外，一旦涉及到改动可能有需要考虑线程安全的问题。
听起来是不是和static全局对象的作用很相似？不过如果你能记起Effective C++中的内容，就会知道静态全局变量的初始化顺序是完全看编译器的心情的。虽然同一个编译单元内的静态全局变量初始化顺序是一定的，但若是不同编译单元内的静态全局变量产生了相互依赖，结果可能就会变得不可预料。
但我们可以通过一个静态的方法，获取只初始化一次的实例对象。这就是单例模式的实现方式。
需要定义的方法和成员变量  既然是需要访问这个全局实例，一定是通过一个静态的类方法获取这个实例的指针或者引用； 单例类不能有公有的构造函数，那么一个共有的析构函数也就变得没有意义； 显然单例类不能有任何公有的拷贝和赋值的行为； 单例类应该需要有一个指向全局唯一实例的指针，为了让静态方法能够获取到这个实例指针，该指针也应该是静态的。  暂时就想到这么多，下面再来思考单例类实例化的时机。是的，单例类要有一个全局唯一的实例，且又不能在外部显示实例化，那就只有一个方法，将构造函数声明为私有的或者保护的，并在某些时刻调用它。
根据调用单例类实例化的时机，可将其分为懒汉版单例模式（Lazy Singleton）和饿汉版单例模式（Eager Singleton）。
Lazy Singleton 顾名思义，什么是懒汉，就是不到万不得已不进行实例的初始化操作，也就是第一次调用GetInstance获取实例对象时才进行初始化：
// 单例模式 class Singleton { public: static Singleton *GetInstance(); // 禁止拷贝和赋值, delete需要在public中实现  Singleton(const Singleton &amp;amp;) = delete; Singleton &amp;amp;operator=(const Singleton &amp;amp;) = delete; private: Singleton(); ~Singleton(); static Singleton *instance; }; Singleton *Singleton::instance = nullptr; Singleton *Singleton::GetInstance() { if (instance == nullptr) { instance = new Singleton(); } return instance; } Singleton::Singleton() { std::cout &amp;lt;&amp;lt; &amp;#34;singleton ctor&amp;#34; &amp;lt;&amp;lt; std::endl; } Singleton::~Singleton() { std::cout &amp;lt;&amp;lt; &amp;#34;singleton dtor&amp;#34; &amp;lt;&amp;lt; std::endl; } 然后我们在main函数中观察一下实例化的时机：</description>
    </item>
    
    <item>
      <title>使用传值和std::move代替传引用可能是更明智的做法</title>
      <link>https://chongg039.cn/post/pass-by-value-then-move-in-ctor/</link>
      <pubDate>Thu, 06 Feb 2020 19:43:22 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/pass-by-value-then-move-in-ctor/</guid>
      <description>这里承接上一篇，继续阐述本人对右值引用、移动构造、移动语义以及编译器优化的一些看法。
问题的出现 假设编写一个类的带参数的构造函数（注意，不是默认构造，也不是拷贝构造和移动构造）：
我有这种想法：因为我这个函数既要支持左值实参，也要支持右值实参，所以要对这个构造函数进行重载。但Clang-Tidy会给出这样一条建议：
Clang-Tidy: Pass by value and use std::move 这让我很疑惑，一般不是会建议传引用减少拷贝对象产生的开销吗。当我点击了这条建议，第一个构造函数被替换成了：
explicit Obj(std::string s) : s_(std::move(s)) { std::cout &amp;lt;&amp;lt; &amp;#34;copy&amp;#34; &amp;lt;&amp;lt; std::endl; }; 传入了一个值，为了防止引发拷贝，直接对这个值使用移动语义，首先这里的形参看起来是没有规定是左值还是右值的，但前面说过，移动语义是将一个左值引用转换为一个右值引用，从而引发std::string的移动构造，那这样看起来这个构造函数还是只能接受左值实参，因为对右值使用移动语义会引发什么，现在不得而知。
所以这条建议也只是将第一个构造函数替换掉了，第二个还是保留。我现在构造一个临时对象理论上会调用第二个构造函数，但实际上不是这样：
编译器显示调用的构造函数有歧义，这是什么情况！也就是说我给构造函数传入了一个右值引用，第一个使用了移动语义的构造函数也能被调用。行吧，编译器蒙了，我也蒙了。
那大不了我把第二个去掉好吧，去掉之后：
竟然一切正常！那这就证明了两点：
 值形参不区分左值引用和右值引用（从行为上来看）； 使用“传值+移动语义”编写函数，可以减少函数重载。  但这也至少有了一个问题，就是对一个右值引用使用移动语义会出现什么情况？换句话说，右值和左值的真正区别应该不止上篇博客说的那些。
右值引用是一个左值 这里在之前看吴咏炜老师的文中提到过，当时是保持一个怀疑态度的。写完上一篇文章后对这个基本赞同，毕竟右值引用可以取地址可以赋值，所有的行为和左值几乎一模一样，但还是没有一个直观的感受。
而且上一篇文章中有个观点是有一些问题的（现已更正）：将亡值是一个纯右值，这是我理解有误。事实上从吴老师画的一张图可以看出：
首先对吴老师的这张图片表示感谢。从图上来看，一个将亡值（xvalue）即是一个右值（rvalue），也是一个广义左值（glvalue），而非是一个纯右值（prvalue）。那么纯右值和将亡值到底有什么区别呢？
事实上，在C++11之前，一般只有右值这样一种说法。在C++11提出了移动函数、移动语义之后，可以将xvalue视作一种语法糖。纯右值一般是纯粹的字面量，或是一个不具名的临时对象。但为了C++适应语言层面更广的情况，便提出了右值引用这样一种新的类型，使用所谓的“资源管理权转移”的方式，来减少拷贝资源带来的开销。对于一个（临时）对象，一旦他完成了资源的转移，也就可以被析构掉了。换言之，当一个右值对象“将要”进行某些个初始化或者赋值操作，我们就可以认为他是“将亡”的，因为一旦这个动作进行完毕，他就会被析构掉。
为了方便移动构造和移动赋值，C++11便对这类右值赋予了一个新的值类别“将亡值”，用以和纯粹的字面量做区分。事实上，我们有时候没必要区分的这么细。
再回到这个小标题，右值引用是一个左值。事实上这句话应该是：具名的右值引用是左值。什么是具名呢，看几个例子：
// 自增自减 ++i; // 左值，先加再返回，返回的是i，具名，所以是左值 i++; // 右值，先返回一个临时的副本在加，这份拷贝不具有名字  // 解引用和取地址 *p; // 左值，获取的是一个存在的实体，&amp;amp;(*p)也成立 &amp;amp;a; // 右值，取地址得到的是一个纯粹的字面量  // 其他一些操作符 a+b; // 右值 a==b; // 右值  // 例外，字符串字面量是一个左值，可以取地址 &amp;amp;&amp;#34;hello&amp;#34;; // 成立，是左值  void test(Obj &amp;amp;&amp;amp;a) { Obj b = a; // 继续访问a } // 如果Obj声明了移动构造，那么这个赋值操作理应调用移动构造函数。但事实上，当一个右值引用传入函数对象内，其类型就将会变成左值（命名对象）。那么这个赋值操作就将会调用Obj的拷贝构造函数，之后继续访问a在堆上的资源也是合理的。  // 事实上，若test声明的返回值是一个左值引用，然后返回一个a，也是对的。这也印证了右值引用传入参数后会变成一个左值，因为一个右值引用是不能绑定到一个左值引用上的。 关于左值和右值暂时就说到这吧，感觉头有点晕……C++11本身是为了逻辑上方便和提高效率才搞出了移动构造、移动赋值和将亡值这些东西，但就是有点费脑子……</description>
    </item>
    
    <item>
      <title>右值引用、移动构造和移动语义std::move</title>
      <link>https://chongg039.cn/post/rvalue-reference-and-move-ctor/</link>
      <pubDate>Sat, 01 Feb 2020 10:02:22 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/rvalue-reference-and-move-ctor/</guid>
      <description>前段时间在读Effective C++，当时对书中提到的移动构造函数一知半解。最近在做项目的时候遇到并重新思考了一下这个问题，在这里写一下自己的浅见。这里假设你已经理解并能熟练运用copy constructor以及copy assignment了。
左值与右值 介绍这个的文章很多，这也是理解什么时候调用拷贝构造、什么时候调用移动构造的一个比较关键的地方。
左值（lvalue） 左值（左值引用）是一个可被赋值的对象，通常出现在赋值表达式等号的左侧。有文章将左值定义为非临时的对象，即可以在后面被使用、被引用，如：
int i = 0; std::string s{&amp;#34;hello&amp;#34;}; 这里的i和s都是左值，后面都可以使用这两个非临时对象。
右值（rvalue） 与之对应，右值不可以被赋值，通常是一个临时对象。如上面的0、&amp;quot;hello&amp;quot;就是右值，只在当前语句中生效，脱离了当前语句的话一般不能在下面的句子中获取到，一般也不具备实际意义。
这里需要注意几点：
  C++11前，最多可以用一个常量引用绑定一个右值在下文使用，但这样绑定的右值不能被修改：
const int &amp;amp;i = 1; // can not be changed ``
  右值本身不是不能修改的，如上文所说，临时对象都是右值，那么调用一个临时对象的setter方法即可修改这个临时对象：
T().set_value(); ``
  这里比较需要注意的是，临时对象都是右值，准确的说是一个“将亡值”，这对于返回值为non-trivial对象的函数有关键性的意义。
左值和右值的符号表示 函数传参时，&amp;amp;表示接受一个左值，为了与之区分，&amp;amp;&amp;amp;表示接受一个右值，看下面这个重载函数：
void RecvValue(int &amp;amp;i) { std::cout &amp;lt;&amp;lt; &amp;#34;get a lvalue&amp;#34;; } void RecvValue(int &amp;amp;&amp;amp;i) { std::cout &amp;lt;&amp;lt; &amp;#34;get a rvalue&amp;#34;; } void Wapper(int &amp;amp;&amp;amp;i) { // 注意这种情况，调用的是第一个  // 因为临时对象在参数传递时会变成命名对象（左值）  RecvValue(i); } 一般也称一个T &amp;amp;&amp;amp;t为一个右值引用。</description>
    </item>
    
    <item>
      <title>2019 年终总结</title>
      <link>https://chongg039.cn/post/2019-summary/</link>
      <pubDate>Wed, 29 Jan 2020 19:51:25 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/2019-summary/</guid>
      <description>看日期就知道，这篇总结其实是在2020年初，由于流感肆虐出不了门，在家里写了补上的。最近发生了许多大事，包括我最喜欢的NBA球星因意外离去，让人痛心。对于这些事情下面一概不谈，就简单回顾一下2019年我做的主要工作、收获，以及对未来的一些展望吧。
项目经历 首先是研究生期间的工作。从六月份的暑假开始研一结束，也标志着我们这一届正式开始做这个国家重点研发计划立项的项目。虽然已经是第二期了，但是由于中间断过档，之前的文档不完善，再加上老师要求全部换用新的技术栈，一开始也是很迷茫，不知道如何下手。幸得师兄和同门们的互相鼓励和帮助，让这个项目得以有了一个初步的雏形。我和一帮同志主要是负责项目的自然语言理解部分，也是最前端的部分，需要将文字叙述转化成我们能够使用的知识表述类型。鉴于有的部分涉及保密，这里只能说明一下大概的整个的摸索过程。
六到八月份，我主要是在用深度学习探索解决这方面问题的可能性，因为研一的时候自己摸索过、请教过一些问题，自己也对这些端到端的方法比较感兴趣。加上18-19年不是提出了Bert和Transformer嘛，没别的，就是强，就是好用。而我们这边的大类问题也无非就是一些传统的NER、RE还有指代消解什么的，就想在传统的标注网络和分类网络上搞搞创新，看看可不可行。不谦虚地说，那时候不屑于和他们做理论的人一样，拿一个写好的模型改一改，甚至调调参数，就写个论文发出去了。咱真是心气高，想把里面的原理彻底搞懂，就是生写，从最原始的来，手动求梯度，在纸上算好各个张量的维度，模仿别人搞数据预处理，再从头开始用TensorFlow一步一步编写各个网络模块，最后再去验证模型的效果。当然上面这些自夸都是玩笑话哈哈，回头想一想这也许就是我为什么发不出论文来了吧……不过说实在的，这段时间的经历，不断地去想去算、再去问师兄解答疑惑，最后再用代码真正将其一步一步实现出来，确实让我受益良多。直接导致的一个后果就是之后基本再出什么新的网络模型，都能比较快的去理解作者的本意，毕竟大部分是些换汤不换药的东西……
上面的话可能有些引战了，受到冒犯的朋友们还请不要当真哈哈。话说回来，为什么最后我们的项目中不以这些深度网络模型为主呢。随着项目的推进，我在其中发现的一个主要问题是，在我们这个限定领域内做知识表示和自然语言处理要求极度精确，就是像我们老师希望达到的是百分之百的准确那样。这和在开放领域当中不同，因为语言这个东西是因人而异的，再说从概率上说也不能保证事情发生的绝对正确性（我指的是在NLP领域中）。那么如何在限定领域内无限逼近这个要求呢，我想出来的方法就是让纠错的代价逼近在这个领域内能逼近的最小。这样说有些抽象了，其实就是如果系统出了错（不论是线下调整还是上线后），能够以最快的方式、最小的代价将问题修复，那么在一个有限的时间内，系统将是越来越精确的，也就是说是朝着百分之百精确的方向前进的，就可以了。
一个深度学习模型不可能达到这个效果，至少在我落笔的此刻我还没有见过这种类型的模型。假设我的分类网络用100万特定领域的语料训练出来了99.5%的准确度（我们就算假设这个是测试集准确率），现在遇到了一条错误的数据，如何让模型学习到这条数据？换言之如何让模型在原有的数据不受影响的情况下，将模型的精确度进一步提高。有人会说加数据，但加多少，如何加，又为什么能保证现有的正确的不会受到影响，至少现在的深度学习理论层面很难解释这个问题。
看到这里有人可能会觉得我说的这些问题，一看就是一个半吊子写出来的，根本不懂深度学习中的数学原理。的确，深度学习训练出来的模型本身就是一个概率模型，然后又妄图用非概率的方式去阐述它、应用它，是有些让人啼笑皆非。但我想说，这是我在具体业务中实践、感悟并总结出来的、仅适用于我们这个特殊项目的部分业务的一些经验。如果存在了某些出错但又必须要修正的情况，而方案本身修正它的代价又很大（就比如在这个项目中用神经网络做主要方案），那么能不能考虑一些其他的方案，将其作为新方案的补充，也未尝不可。
理清了这个思路，就是一步一步来，多看多尝试，最终敲定了一个比较合理的方案，也经过了项目组内部的高强度测试检验和完善。在这四个多月的过程中，我比较满意的是总结出了一套完整的在我们这个限定领域内的自然语言理解方案，重构了三次代码，剥离了许多子问题，并对这个领域有了更加深刻的认识。你说现在已经到了完美的程度了吗？当然没有，甚至说还远得很，但至少和我预想的一样，整体逻辑处于一种可控、易修正的状态，这已经令我很满意了。
从项目里面学到的另一个技能便是写文档。在项目进行到中期时，我越来越觉得维护一个内部的技术文档是多么的重要。不单单是为了将来的交接，也对自己回顾整理，乃至项目重构时有很大的帮助。代码注释在帮助理解项目整体思路上贡献甚微。因此我在内部服务器上搭建了一个gitbook作为项目文档，确实很有帮助。
这学期还做了一些内部零零散散的小项目，当然和这个主要的相比就显得有些微不足道了，也只是帮助了自己回顾了一下MySQL、TCP方面的一些知识。篇幅有限，不提也罢。
比赛 十月份初期拿了十天左右做了个天池的比赛，取得了一个还可以的成绩，之前有篇文章写过这部分内容，也不再啰嗦了。其实这不是第一个比赛，19年上半年做了个kaggle的，还有暑假做了个追一科技的，都不是很差当然也算不上好。虽然之后可能并不找算法为主的工作，但还是会做一下相关的比赛，一方面是增加经历，长长见识，另一方面还是要给枯燥的研究生生活增加点趣味性和挑战性。研究生研究生嘛，即便有项目不写论文，也不能老是重复着单调的工作。
之后的想法 首先是以后要做什么。很惭愧以前还说要做理论，要做算法，这还没有一年就发现自己不是这块料。当然如果以后的业务能是开发带一点算法，就更好了。有挑战性的工作就像玩游戏一样。
我在做这个项目的时候主要用的是python，这是出于两个因素。第一是许多深度学习的模型是用python写的，之前写的一些模块可以复用，也自然而然的用python编写现有的业务；第二是python确实简单易用，适合快速迭代开发。那时项目催得紧，用C++、Java不知道得开发到猴年马月，人手又少，所以也是赶鸭子上架。
现在项目迭代也几次了，也有时间回过头来审视语言层面的一些问题。这里我不是带语言优劣的节奏，就说一个很现实的问题，现在做开发，用python找不到工作啊！我本人在本科期间由JS、NodeJS、Golang一路做过来，就是因为本科期间C++没有学好，也成了我心中的一直以来的一个遗憾。既然上天给了我再一次选择的机会，我决定再向C++挑战一次。除了这些，我从本科大二开始就一直以Linux做主要开发环境，对深层次的编译、链接这些东西要比JVM虚拟机更加着迷（尽管知识水平并不允许我这么做）。因此，我也用业余时间将整个项目用C++重构了一次，尽管由于一些原因当时并没有完成，但我还是会在2020年的上半年再次迭代一个C++的正式版本，作为对自己实践能力的一次检验。
名著，主要就是阅读了C++ Primer、Effective C++和STL源码剖析这三本比较经典的，其中后两本读起来真是有一种酣畅淋漓的感觉，反倒是前一本可能是太过于大而全，有点长篇大论的啰嗦感。很感谢我的鹅厂师兄不厌其烦地帮我解惑，希望自己也早日达到这个高度。
结语 这次回家前也是去青岛中转了一下，找了找几位比较铁的同学了解下近况，畅谈了理想。有不堪工作繁重的，也有日子有奔头充满希望的，让还身为学生的我感触颇多。加上年后爆发的这次疫情以及种种意外，让人更加感叹世事的无常。活在当下，珍惜眼前，回去后好好撸码，勤去健身。</description>
    </item>
    
    <item>
      <title>天池全球数据智能大赛（赛场二）第7名解决方案</title>
      <link>https://chongg039.cn/post/yield-prediction-competition/</link>
      <pubDate>Tue, 22 Oct 2019 19:46:49 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/yield-prediction-competition/</guid>
      <description>第一次正儿八经组队参加的比赛，虽然没能拿到奖金但也取得了一个比较满意的成绩（初赛23复赛7），这里记录一下当时的解决思路。
首先这是一个农作物产量预测的比赛，属于比较传统的回归分析，这种类型的比赛只要做好 EDA ，一般都能取得不错的成绩，而不是说设计了一个多么精妙的网络结构。事实上官方提供的数据集最大的问题就是少，而且样本分布严重不均，这也成为了赛后受大家诟病的一个主要方面。
探索性数据分析（EDA） EDA of train data 取以下数值型天气特征并分析之间的相关性：
{ &amp;#34;日照时数（单位：h)&amp;#34;: &amp;#34;day_sun_hour&amp;#34;, &amp;#34;日平均风速(单位：m/s)&amp;#34;: &amp;#34;day_mean_wind&amp;#34;, &amp;#34;日降水量（mm）&amp;#34;: &amp;#34;day_rain&amp;#34;, &amp;#34;日平均温度（单位：℃）&amp;#34;: &amp;#34;day_mean_temperature&amp;#34;, &amp;#34;日相对湿度（单位：%）&amp;#34;: &amp;#34;day_relative_humidity&amp;#34;, &amp;#34;日平均气压（单位：hPa）&amp;#34;: &amp;#34;day_mean_pressure&amp;#34;, &amp;#34;日最高温度（单位：℃）&amp;#34;: &amp;#34;day_high_temp&amp;#34;, &amp;#34;日最低温度（单位：℃）&amp;#34;: &amp;#34;day_low_temp&amp;#34; } 以2017年区县id为16的地区为例：
可以得出：
 一个地区一年的日平均温度、日最高温度和日最低温度呈正相关； 以平均温度为例，日平均气压与日平均温度呈负相关。  取以下类别型天气特征并处理：
{ &amp;#34;02时风向&amp;#34;: &amp;#34;day_02_wind&amp;#34;, &amp;#34;08时风向&amp;#34;: &amp;#34;day_08_wind&amp;#34;, &amp;#34;14时风向&amp;#34;: &amp;#34;day_14_wind&amp;#34;, &amp;#34;20时风向&amp;#34;: &amp;#34;day_20_wind&amp;#34; } 做连续特征的话，依据下面的映射表映射到数值特征上：
{ &amp;#34;N&amp;#34;: 0, &amp;#34;NNE&amp;#34;: 22.5, &amp;#34;NE&amp;#34;: 45, &amp;#34;ENE&amp;#34;: 67.5, &amp;#34;E&amp;#34;: 90, &amp;#34;ESE&amp;#34;: 112.5, &amp;#34;SE&amp;#34;: 135, &amp;#34;SSE&amp;#34;: 157.5, &amp;#34;S&amp;#34;: 180, &amp;#34;SSW&amp;#34;: 202.5, &amp;#34;SW&amp;#34;: 225, &amp;#34;WSW&amp;#34;: 247.</description>
    </item>
    
    <item>
      <title>[基础知识]C&#43;&#43;基础知识汇总</title>
      <link>https://chongg039.cn/post/cxx-base/</link>
      <pubDate>Sun, 20 Oct 2019 15:51:31 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/cxx-base/</guid>
      <description>指针和引用 联系 C++底层中引用是通过指针实现的，在实现层面上引用就是指针，指向同一对象的内存地址。
所有对引用的操作就是对原始对象的操作。
区别  引用只是别名，不是实体类型，因此编译器不为引用分配单独的内存空间，而指针有自己的内存空间，因此某种程度上指针不能被引用取代； 引用必须被初始化且不能为空，但可以有未初始化的空指针； 引用一旦初始化就不能更换目标，即不能被初始化多次，指针可以更改指向的对象； 可以有指针数组，不能有引用数组，因为引用没有被分配内存； 当引用作为函数的形参时，因为函数形参和实参是同一个对象，避免了复制对象的开销； 若对引用型参数做const修饰，则不会调用拷贝构造函数，提高效率； 若引用作为函数的返回结果，需要保证函数返回后被引用的目标一直有效，即不能返回函数内部的局部对象的引用（因为离开作用域后会被析构掉）。  数组和指针 C++不记录数组本身的大小，因此一定注意不要越界访问。
数组作为形参传递时会退化为同类型的指针：
int data[] = {1, 2, 3, 4, 5}; int size1 = sizeof(data); // 20 int *data2 = data; int size2 = sizeof(data2); // 4  int GetSize(int data[]) { return sizeof(data); } int size3 = GetSize(data); // 4 sizeof使用与陷阱 https://www.cnblogs.com/chio/archive/2007/06/11/778934.html
内存对齐 尽管计算机中内存是按照字节byte划分的，但不是寻址可以从任意的byte开始。一般来说计算机会对基本数据类型数据在内存中存放的位置加以限制，要求首地址必须是某个数（一般是4和8）的倍数，这就是内存对齐。
因为虽然计算机按照字节划分存储空间，但处理器存取一次内存不是按照一个字节存取的，一般以双字节、4字节、8字节甚至到32字节存取。这被称为内存存取粒度。
对32位处理器的int类型（4字节），若数据现在可以存放在任一字节开始处，会产生性能的损失。比如，现在从地址1字节开始存放int（1-5，左开右闭），读取时从0字节开始读取一个4字节大小的块，需要访问两次内存。第一步先读取0-4左开右闭字节快，剔除0地址字节；第二步访问4-8左开右闭字节快，剔除5、6、7三个字节块。然后将这两部分得到的合并放入寄存器，需要做很多工作。有了内存对齐，那么只能从规定的边界存放和读取，访问一次内存就可以了。
设置编译器的”对齐系数(对齐模数)“的预处理指令为#pragma pack(n)，一般32位系统下对齐系数为n=4，64位系统下对齐系数为n=8。还有一个概念为”对齐单位“，也称有效对齐值，是指n和结构体中最长数据类型（基本数据类型）长度中较小的那一个值。
下面说一下内存对齐规则，主要有两条：
 结构体中第一个成员的offset为0，之后每个成员都相对首地址的offset都是”该成员大小“和”对齐单位“中较小的那个的整数倍。如有需要可以添加进填充字节； 结构体的总大小为”对齐单位“的整数倍，如有需要会在最末尾成员添加填充字节。  分析下下面三个例子：
#pragma pack(4) // 先使用第一条规则 // 对x, 对齐单位min(4, 4) = 4, 按照4字节对齐, 不用偏移, 从0开始占用4个字节 // 对c1, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从4开始占用1个字节 // 对c2, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从5开始占用1个字节 // 再使用第二条规则, 结构体大小需要是对齐单位的整数倍, 补2个字节在末尾 // sizeof(x1) = 8 typedef struct x1 { int x; char c1; char c2; } x1; // 先使用第一条规则 // 对c1, 对齐单位min(4, 1) = 1, 按照1字节对齐, 不用偏移, 从0开始占用1个字节 // 对c2, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从1开始占用1个字节 // 对x, 对齐单位min(4, 4) = 4, 按照4字节对齐, 相对于首地址偏移min(4, 4) = 4的倍数, 需要先填充2位, 再从4开始占用4个字节 // 再使用第二条规则, 结构体大小需要是对齐单位的整数倍, 不用补填充字节 // sizeof(x2) = 8 typedef struct x2 { char c1; char c2; int x; } x2; // 先使用第一条规则 // 对c1, 对齐单位min(4, 1) = 1, 按照1字节对齐, 不用偏移, 从0开始占用1个字节 // 对x, 对齐单位min(4, 4) = 4, 按照4字节对齐, 相对于首地址偏移min(4, 4) = 1的倍数, 需要先填充3位, 再从4开始占用4个字节 // 对c2, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从8开始占用1个字节 // 再使用第二条规则, 结构体大小需要是对齐单位的整数倍, 补3个字节在末尾 // sizeof(x3) = 12 typedef struct x3 { char c1; int x; char c2; } x3; #pragma pack() 准确地讲这是属于内存的字节对齐。还有一个问题是大端对齐和小端对齐，这和处理器的架构有关系。大端对齐模式就是数据的低位保存在内存的高地址，内存的低地址存放着数据的高位。小端对齐模式就是数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。一般都是使用小端对齐的方式，大端对齐主要用在一些大型机的处理器中。</description>
    </item>
    
    <item>
      <title>2019 年中总结</title>
      <link>https://chongg039.cn/post/2019-mid-term-summary/</link>
      <pubDate>Sun, 12 May 2019 19:10:25 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/2019-mid-term-summary/</guid>
      <description>今年上半年也快过完了，回顾一下半年来的一些工作，觉得也算是小有成长。
生物信息 说实话我不太想回忆起这部分经历，毕竟跨学科学习对于我一个毫无生信方面经验的计算机学生来说实在是太痛苦了，还是跨的生物。
最开始在和师兄一起做基因优化和密码子聚类的工作。说实话导师在密码子聚类方面的一些想法确实很不错，也曾让我激动过一阵。但经历过无数次实验验证后也渐渐熄灭了热情，剩下的只有接踵而来的失败和迷茫。师兄密码子优化方面的工作小有成果，并且能和川大国家重点实验室的同学们共事过一段时间，也是让我感到非常荣幸的一件事。
搁置了这块工作后，我的导师便让我转向了蛋白质结构预测的工作，并曾信心满满地说“我们一定要参加2020年的 CASP 大赛”，仿佛 Alpha-Fold 的成功明天就会发生在我们身上一般。没办法，赶鸭子上架也得学呀。在详细了解了这个比赛后，知道了大家使用的模型都是一个双层的残差网络，也顺利地在 Github 上找到了一个实现。模型训练出来后，老师比较高兴，但也没有什么后续的动作了。我也乐的清闲，能少跟生物沾边就少沾边。
上半年最后做的一个和生信相关的小项目是药物-靶点预测系统，这个的实现也是参考的清华的一篇 nature 的论文。从这个项目中第一次系统地接触到了推荐系统，原理部分结合上学期修的矩阵理论也没有什么理解上的难点。在实验室做的第一篇论文分享也是这个，总的来说收获较大，也许工作后会考虑去做推荐算法。不过项目本身按照我老师的脾性，仍然搁置了就是了。
上半年做的生信方面的工作也就这些，没有锻炼出生物专业方面的技能，杂的倒是学了不少。也很感谢我在海洋大学的同学和她的师兄们，给予了我很大的帮助。不过我还是想说一句，我对生信一丁点的兴趣都没得。
自然语言 很显然，和川大在生物方面项目进展的并不顺利，我就被发配去了自然语言组。我是十分高兴的，一方面是自己本身对 nlp 比较感兴趣，同时做 cv 人太多了，另一方面是原来生信方面的工作大部分也是在处理氨基酸序列和 DNA 序列，和自然语言语料有共通之处。
第一个做了一个实体关系抽取器，用在我们的项目中抽取实体关系三元组，但准确的来说实体抽取是师兄的工作，我这边只是做了一个关系分类器。大概的思路就是使用字向量+实体的位置向量编码，输入到一个双向的 LSTM 中训练，最后输出到 softmax 分类器中。因为是用的语料都是短句，所以最终模型表现也比较好。
在这个项目中我觉得收获还是很大的，因为从设计模型、处理语料、参数调整，到中间矩阵的维度确认，一行行敲出代码并做调试，前前后后耗费了一周多的时间。其中最复杂的地方我觉得是在数据预处理部分，模型也就是多个中间矩阵的维度计算比较麻烦（我是全部画出来并手动计算的，原谅我的菜）。说来惭愧，通过这个过程我才第一次才真正理解了网络中每一步在做什么。以前虽然调试过许多模型，看过许多相关的书和视频，你要是让我去说名每一层网络中的参数是多少，为什么是这样，我还真有可能答不上来。
师兄肯定了我的工作，然而当我拿去给导师看的时候，导师却认为统计模型和深度学习模型都不能达到我们项目中要求的接近 100% 的分类准确率，并认为依存句法分析就可以解决大部分问题，让我回去重新用句法分析器做。有了前几次的经历，这次我已经有了心理准备，但心里还是有点不爽。
那能怎么办呢，做呗，只能拿哈工大的 LTP 基于句法分析树尝试去抽取关系。但依存树都是从一个动词开始分析句子的依存结构，抽取出来的事实三元组并不是我们需要的（实体1，关系，实体2）这种。在尝试了许多方法后，发现依存句法只能解决一些非常简单的题目，对那种多个实体的复杂长句就非常难以设计分析路径了。抛开使用深度网络的方法，现在要想解决关系抽取问题，目前只能依靠句模和规则库来构建了。
总的来说，这一段时间在 nlp 方面也算入了门，最重要的是找到了一个比较喜欢的方向，有机会的话也希望将来能从事这方面相关的工作。
阅读 之前说过我买了一个 kindle ，也算汇报一下情况吧。
最近读完了吴军老师的两本书：数学之美和浪潮之巅。其实我主要想说一下这两本书的写作风格我非常喜欢，平铺直叙却又耐得住咀嚼。我本人是非常喜欢看纪录片的，而且也一直认为能把晦涩难懂的知识以一种简洁明快而不枯燥的方式向人们普及是一种非常了不起的能力，而吴军老师恰恰就拥有这种能力。
我其实不太喜欢写博文，觉得有这种时间不如用来学习一些新的知识。但是自从买了 kindle 后，静心阅读的时间变长了，利用手机等方式的碎片化阅读变少了，有了更多的时间去思考平时遇到的问题，整个人也变得不是那么的浮躁。
能把自己遇到的问题，自己的想法记录下来，既是温故，又能知新，还可以与他人碰撞思维的火花，何乐而不为？可能是受到吴军老师的影响，现在的我的确是这么想的。希望将来有一日，我也能以一种优美而简洁的语言写下自己的想法，分享给他人。</description>
    </item>
    
    <item>
      <title>高级计算机视觉知识点总结</title>
      <link>https://chongg039.cn/post/advanced-computer-vision/</link>
      <pubDate>Sun, 12 May 2019 19:09:40 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/advanced-computer-vision/</guid>
      <description>我自己在做的方向是 NLP 相关，但这学期也选修了高级计算机视觉这门课程，其中很大一部分内容都是传统的视觉算法，和现在被人熟知的机器学习相关的 CV 领域还是有很大区别。由于这门课程也是学院第一次开课，所以也没有办法去做针对性的复习，故在此作以下学习记录，写下自己的理解，希望将来能温故而知新。
特征提取算法 涉及到的特征提取算法主要有 Harris 角点检测算法、Canny 边缘检测算法和 SIFT 尺度不变特征变换算法。
Harris Corner Detection 首先要理解角点和其具有的特征：
 角点是轮廓之间的交点 针对同一场景，即使视角发生变化，角点通常仍具备稳定的特征 角点附近的区域的像素点的梯度无论是方向还是幅值都会有较大的变化  针对以上角点的特征，Harris 算法的基本思想是：使用一个固定大小的窗口在图向上进行任意方向上的滑动，比较滑动前后的窗口中像素灰度变化的程度。若沿任意方向的滑动都有较大的灰度变化，则认为该窗口中存在角点。
现在要做的就是设计一个函数，来衡量滑动前后的灰度值变化，并设置一个阈值，当灰度变化超过这个阈值认为存在角点。
这个函数可以作如下表示：
$$ E(u, v) = \sum_{x, y} w(x, y) [I(x+u, y+v) - I(x, y)]^2 $$
其中 $w(x, y)$ 是窗口函数（矩阵），常用的有 (0, 1) 函数和高斯函数，$I(x, y)$ 表示灰度强度值。下面要用到泰勒展开式处理这个函数。
二维泰勒展开式为：
$$ f(x+u, y+v) = f(x, y) + uf_x(x, y) + vf_y(x, y) + &amp;hellip; $$
抛开 $w(x, y)$ ，先处理 $\sum[&amp;hellip;]^2$ 这部分：</description>
    </item>
    
    <item>
      <title>蛋白质结构预测比赛知识储备</title>
      <link>https://chongg039.cn/post/knowledge-of-casp/</link>
      <pubDate>Thu, 17 Jan 2019 14:25:08 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/knowledge-of-casp/</guid>
      <description>生物分子结构 有关生物分子四级结构的信息请参照维基百科相关词条。
蛋白质结构表征方式（氨基酸残基）  接触图（contact maps），接触图使得不需要 3D 渲染软件，就能够快速形象化地探索结构特征。此外，接触图的基本 2D 矩阵（称为接触矩阵），能够天然地作为随后自动知识发现或机器学习任务的数值输入。 距离图（distance maps） 氢键图  氨基酸（Amino acids） 氨基酸残基（amino acid residue） 组成多肽的氨基酸在相互结合时，由于其部分基团参与了肽键的形成而失去一分子水，因此把多肽中的氨基酸单位称为氨基酸残基，即由肽键链接的氨基酸失水部分。
它是一个分子的一部分，而不是一个分子。
氨基酸的氨基上缺了一个氢，羧基上缺了一个羟基。
简单的说，氨基酸残基就是指不完整的氨基酸。一个完整的氨基酸包括一个羧基（—COOH)，一个氨基(—NH2)，一个H，一个R基。缺少任何一个部分都算是氨基酸残基，并没有包括肽键的。
如甘氨酸残基为：—NH—CH2—CO—。
蛋白质中氨基酸残基数目的估算：氨基酸残基的数目=蛋白质分子量/110
蛋白质结构 蛋白质结构是指蛋白质分子的空间结构。作为一类重要的生物大分子，蛋白质主要由 碳、氢、氧、氮、硫等化学元素组成。所有蛋白质都是由 20 种不同的 L 型 α 氨基酸连接形成的多聚体，在形成蛋白质后，这些氨基酸又被称为残基。蛋白质和多肽之间的界限并不是很清晰，有人基于发挥功能性作用的结构域所需的残基数认为，若残基数少于 40 ，就称之为多肽或肽。要发挥生物学功能，蛋白质需要正确折叠为一个特定构型，主要是通过大量的非共价相互作用（如氢键，离子键，范德华力和疏水作用）来实现；此外，在一些蛋白质（特别是分泌性蛋白质）折叠中，二硫键也起到关键作用。为了从分子水平上了解蛋白质的作用机制，常常需要测定蛋白质的三维结构。由研究蛋白质结构而发展起来了结构生物学，采用了包括X射线晶体学、核磁共振等技术来解析蛋白质结构。
一定数量的残基对于发挥某一生物化学功能是必要的；40 - 50 个残基通常是一个功能性结构域大小的下限。蛋白质大小的范围可以从这样一个下限一直到数千个残基。目前估计的蛋白质的平均长度在不同的物种中有所区别，一般约为 200 - 380 个残基，而真核生物的蛋白质平均长度比原核生物长约 55% 。更大的蛋白质聚合体可以通过许多蛋白质亚基形成；如由数千个肌动蛋白分子聚合形成蛋白纤维。
不同层次的蛋白质结构 蛋白质的分子结构可划分为四级，以描述其不同的方面：
 蛋白质一级结构：组成蛋白质多肽链的线性氨基酸序列。 蛋白质二级结构：依靠不同氨基酸之间的 C=O 和 N-H 基团间的氢键形成的稳定结构，主要为 α螺旋 和 β折叠 。 蛋白质三级结构：通过多个二级结构元素在三维空间的排列所形成的一个蛋白质分子的三维结构。 蛋白质四级结构：用于描述由不同多肽链（亚基）间相互作用形成具有功能的蛋白质复合物分子。  除此之外还有侧链结构，根据侧链结构的不同可以分为 20 种常见氨基酸，各自在蛋白质中扮演着重要的角色。
定义不同类型的二级结构有不同的方法，最常用的方法是通过主链原子之间的氢键的排列方式来判断的。而在蛋白质完全折叠的状态下，这些氢键可以得到稳定。
更多详细内容参照维基百科蛋白质结构条目。
蛋白质结构预测 蛋白质结构预测 (Protein structure prediction) 是指从蛋白质的氨基酸序列中预测蛋白质的三维结构。也就是说，从蛋白质的一级结构预测它的折叠和二级、三级、四级结构。当前蛋白质结构预测技术的性能在蛋白质结构预测技术的关键测试（CASP）实验中被评测，蛋白质结构预测的网络服务器连续的评测是由社区项目 CAMEO3D 执行。</description>
    </item>
    
    <item>
      <title>2018 年终自检</title>
      <link>https://chongg039.cn/post/2018-summary/</link>
      <pubDate>Mon, 07 Jan 2019 14:14:55 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/2018-summary/</guid>
      <description>这篇文章现在才写是因为复习矩阵考试而耽误了。在这里提一句感谢寒号鸟学长的知乎专栏以及实验室小伙伴的耐心指点，让我这个数学基础并不是那么好的学生勉强看懂了矩阵理论讲的内容。另外之前翻译的那本书鸽了一段时间，因为我实在没有想到成电的研一课业压力会这么大，也就没有选修随机过程。之后可能会继续进行翻译工作，不过可能进度会比较慢罢了。
2018年对我来说算是比较重要的一年。3月初回学校进行预面试，并且成功通过复式成为了（原）自动推理实验室的一员。整个过程还是很轻松愉快的，当时也感觉 f 老师是个很 nice 的人，虽然现在并不是这么觉得。四五月份抽出时间完成了水水的毕业设计，之后便做了一个比较私人的决定：去一趟稻城亚丁转换下心情，也算是做一次毕业旅行吧。
稻城白塔
牛奶海
牦牛兄弟
虽然恶劣的天体条件和贫瘠的山路让人身心匹配，不过稻城之行还是领略了一下藏区的风土人情，呼吸了一下高原干净的空气。回来后老师叫我去教研室我也找了个借口溜了，回家和爸钓了几天鱼。
研一的生活比我想象的要紧凑很多。我对 f 老师的评价是：一个理想主义的嘴炮王。具体为什么这么评价他就不谈了，估计当你的导师想要同时研究图推理、CV、nlp、小分子合成、基因优化、靶向药生成、量子机器学习的时候，你也会这么评价他。估计之后很长一段时间我也许就要去川大华西那边做实验去了。
相比本科时期的工作室生活，读研的第一个学期还是收获很多的，最起码机器学习方面的知识学习了不少。而且重拾了 C++ ，最近为了863也在重新写起了 Java 。虽然水平不高，但总算是在成长，视野也在开阔。以后也许在 z 师兄的指导下先搞两年 nlp ，毕竟也和 f 老师做的基因序列任务有点关系。前一段时间参加了 kaggle 的一个 CV 比赛，虽然没有实现一个很好的模型，但也算一次体验，之后有想法会继续参加。
读书方面，下半年快年底买了一个 kindle ，虽然目前只是用来看技术相关的书籍。作为我的第一台电子墨水设备体验很不错，以后争取多读一些文学作品。没有时间行万里路，那就争取做到读万卷书。
2019 年还得继续努力，人菜就要多学习。</description>
    </item>
    
    <item>
      <title>我的第一台 kindle</title>
      <link>https://chongg039.cn/post/my-kindle/</link>
      <pubDate>Thu, 03 Jan 2019 20:09:57 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/my-kindle/</guid>
      <description>说来惭愧，一直想入手一个 kindle 但有点舍不得，怕买来成了泡面盖子。一直等到了 KPW4 的发售，张大妈上推送了一个拼多多的链接，800+，带原装保护壳也才850。这岂不是白送？果断下单，也算是为信仰充值了吧。
下面是个简短的开箱。
使用体验：总体来说体验还是不错的，180余克的体重，纯平的屏幕设计，细腻的屏幕，多级的背光以及不算慢的翻页体验，让我对这一款产品还是比较满意的。但是这样一款几年更新一代的产品竟然还在用 Micro USB 的接口，算是唯一美中不足之处吧。
至于使用方式，我主要是用来看一些技术上的书籍，减少自己看手机的时间。看双页的论文是不要想了，在6寸的屏幕上表现简直是灾难。书的获取方式、导入方式有需求的朋友请自行 Google ，我就不再这里传播了，希望以后能尽量支持正版。</description>
    </item>
    
    <item>
      <title>FMAM - 1.7：Additional Topics</title>
      <link>https://chongg039.cn/post/fmam-content-1.7/</link>
      <pubDate>Fri, 03 Aug 2018 08:31:59 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/fmam-content-1.7/</guid>
      <description>第 1.2, 1.3, 1.4, 1.5 和 1.6 节涵盖了 PH 分布和多元 PH 分布的基本理论。在本节中，我们将讨论概括和一些概括 PH 分布的理论问题。
1.7.1 离散的 PH 分布 考虑具有 m + 1 个状态的离散时间马尔可夫链，其概率矩阵为 $$ P= \biggl( \begin{matrix} T &amp;amp; \pmb{T ^ {0}} \\ 0 &amp;amp; 1 \end{matrix} \biggl) $$ 吸收到状态 $m+1$ 的时间表示为 $X$ ，我们将其定义为离散时间的 PH 随机变量。给出初始概率向量 $(\pmb{\alpha}, 1-\pmb{\alpha e})$ ，很容易得到 $$ P\{X=n\}= \begin{cases} 1 - \pmb{\alpha e} &amp;amp; if \quad n=0; \\\
\pmb{\alpha} T ^ {n-1} \pmb{T ^ 0} &amp;amp; if \quad n=1, 2, &amp;hellip; \end{cases} $$</description>
    </item>
    
    <item>
      <title>FMAM - 1.6：PH 分布的参数估计</title>
      <link>https://chongg039.cn/post/fmam-content-1.6/</link>
      <pubDate>Thu, 02 Aug 2018 22:02:09 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/fmam-content-1.6/</guid>
      <description>在概率论、随机建模和统计学中，概率分布的参数估计是一个基本问题。有关参数估计的参考资料的数量是巨大的。在本节中，我们主要讨论 PH 分布的参数估计。
PH分布的参数估计是指为一个来自样本 ${y _ {1}, y _ {2}, &amp;hellip;, y _ {n}}$ 的 PH 随机变量 Y 找到一个 m 阶的 PH 表示 $(\alpha, T)$。样本中，$y _ {k}$ 被称为样本点，n 被称作样本大小。我们假定样本点是独立收集的，那么我们定义 ${Y _ {1}, Y _ {2}, &amp;hellip;, Y _ {n}}$ 是独立同分布的随机变量 (i.i.d.r.v.s) ，它们具有和 Y 一样的分布。样本点 $y _ {k}$ 是 $Y _ {k}$ 的一个实现（可能翻译不准确？）。同样的，我们定义 $\{I(t), t \geq 0 \}$ 作为与 Y 相关的底层马尔可夫链 (the underlying Markov chain) 。
例子1.6.1：略 命题1.6.1 (Asmussen et al. (1996)) ： 对于 $y &amp;gt; 0$ ，我们有 $$ E _ {(\pmb{\alpha}, T)}[B _ i | Y=y] = \frac{\alpha _ {i}b _ {i}(y | T)}{\pmb{\alpha}\pmb{b}(y | T)}, i=1, 2, &amp;hellip;, m $$</description>
    </item>
    
    <item>
      <title>FMAM - 1.5：多元 PH 分布</title>
      <link>https://chongg039.cn/post/fmam-content-1.5/</link>
      <pubDate>Thu, 02 Aug 2018 16:01:51 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/fmam-content-1.5/</guid>
      <description>考虑连续时间上的马尔可夫链 $ \{ Y(t), t \geq 0 \} $，且具有有限状态空间 $ \{1, 2, &amp;hellip;, m \} $，无穷小的生成矩阵 $Q$ 和初始分布 $\alpha$ 。令 $A _ {k} $ 是 $ \{ 1, 2, &amp;hellip;, m \} $ 的子集，其中 $k=1, &amp;hellip;, K$，假设交集$ \{ A _ {k}, k=1, &amp;hellip;, K \} $ 是非空的且马尔可夫链将以 1 的概率被吸收到交叉点。
定义1.5.1 定义 $$ X _ {k} = min{t:Y(t) \in A _ {k}, t \geq 0}, k = 1, &amp;hellip;, K $$ 随机向量 $ X = (X _ {1}, X _ {2}, &amp;hellip;, X _ {K})$ 则被认为具有多元的 PH 分布（MPH）和多元的 PH 表示 $(\alpha, Q, A _ {k}, k = 1, &amp;hellip;, K)$ 。</description>
    </item>
    
    <item>
      <title>FMAM - 1.4：PH 分布和 PH 表示</title>
      <link>https://chongg039.cn/post/fmam-content-1.4/</link>
      <pubDate>Thu, 26 Jul 2018 10:30:01 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/fmam-content-1.4/</guid>
      <description>注：本书中 &amp;#34;order&amp;#34; 译作 “阶“，原因如下： 在 &amp;#34;Stat Trek&amp;#34; 上 &amp;#34;Matrix Order&amp;#34; 的释义为： The number of rows and columns that a matrix has is called its order or its dimension. By convention, rows are listed first; and columns, second. Thus, we would say that the order (or dimension) of the matrix below is 3 x 4, meaning that it has 3 rows and 4 columns. 矩阵具有的行数和列数 称为其 顺序 或 维度 。按照惯例，首先列出行，再给出列。因此，我们可以说下面矩阵的顺序（或维度）是3 x 4，这意味着它有 3 行 4 列。 本文中主要研究方阵，因此将 &amp;#34;the order of the matrix is n&amp;#34; 译作 ”n 阶方阵” 1.</description>
    </item>
    
    <item>
      <title>FMAM - 1.3：PH 分布的闭包属性</title>
      <link>https://chongg039.cn/post/fmam-content-1.3/</link>
      <pubDate>Fri, 20 Jul 2018 15:59:56 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/fmam-content-1.3/</guid>
      <description>在本节中，我们展示了一组 PH 分布在一些操作下是封闭的情况（例如，“min”，“max”，“+”）。闭包属性证明了随机建模中 PH 分布在数学上的动态可操作性，这体现了他们在应用中的关键作用。首先，我们考虑采用马尔可夫链方法练习 1.1.5 , 1.1.6 和 1.1.9 。
例子1.3.1： 假定 $X _ {1} $ 和 $X _ {2}$ 是分别具有参数 $\lambda _ {1} $ 和 $\lambda _ {2} $ 的相互独立的指数随机变量，显示 $min\{X _ {1}, X _ {2}\} $ ，$max\{X _ {1}, x _ {2}\}$ 和 $X _ {1} + X _ {2}$ 服从 PH 分布，并找出对应的 PH 表示。
回想一个和 $X _ {1}$ 相关的两阶段连续时间马尔可夫链，令 $I _ {1}(t)$ 为 $t$ 时刻的底层马尔可夫链的阶段。那么两阶段底层马尔可夫链 $\{I _ {1}(t), t \geq 0\}$ 的无穷小生成矩阵由下面给出 $$ Q _ {1} = \begin{matrix}1 \\ 2 \end{matrix}\begin{pmatrix}-\lambda _ {1} &amp;amp; \lambda _ {1} \\ 0 &amp;amp; 0\end{pmatrix} $$ 其中阶段 2 是吸收阶段。同样地，$I _ {2}(t)$ 由和 $X _ {2}$ 相关联的两阶段底层马尔可夫链定义。两条马尔可夫链 $\{I _ {1}(t), t \geq 0\}$ 和 $\{I _ {2}(t), t \geq 0\}$ 是相互独立的。</description>
    </item>
    
    <item>
      <title>FMAM - 1.2：PH 分布的定义和基本属性</title>
      <link>https://chongg039.cn/post/fmam-content-1.2/</link>
      <pubDate>Thu, 19 Jul 2018 20:11:50 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/fmam-content-1.2/</guid>
      <description>PH 分布在 Neuts（1975）中被引入来概括指数分布。在本节中，我们给出了相位分布的一个代数定义和一个概率定义，并介绍一些基本的属性。
定义1.2.1： 如果非负随机变量 X 的分布函数由下式给出，则它具有相位类型分布（PH分布）：
$$ F(t)=P\{X \leq t\}=1-\pmb{\alpha} exp(Tt) \pmb{e} \equiv 1- \pmb{\alpha}(\sum _ {n=0}^\infty \frac{t^n}{n!}T^n) \pmb{e},t \geq 0 \tag{1.9} $$
其中：
 $\pmb{e}$ 是全为 1 的列向量； $\pmb{\alpha}$ 是 m 阶的随机行向量（substochastic pmbtor 翻译不准确？），即 $\pmb{\alpha}$ 是行向量，$\pmb{\alpha}$ 中的所有元素都是非负的，$\pmb{\alpha} \pmb{e} \leq 1$ ，其中 m 是正整数； T 是 m 阶的子生成矩阵（subgenerator 翻译不准确？），即 T 是 $m \times m$ 矩阵，使得 (1) 对角线所有元素都是负的；(2) 所有非对角线元素都是非负的；(3) 一行所有元素之和均为非正数，且对所有行有效；(4) T 是可逆的。  我们称 T 为 PH 发生器，2 元组 $(\pmb{\alpha}, T)$ 称为 m 阶相位分布的相位表示（PH表示）。</description>
    </item>
    
    <item>
      <title>FMAM - 1.1：指数分布</title>
      <link>https://chongg039.cn/post/fmam-content-1.1/</link>
      <pubDate>Wed, 18 Jul 2018 17:01:14 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/fmam-content-1.1/</guid>
      <description>本章节定义了指数分布和与指数分布相关联的一些基本属性。
定义1.1.1： 如果一个非负随机变量Ｘ的概率分布函数（即累积分布函数 CDF）满足如下形式：
$$ F(t)=P\{X \leq t\}=1-exp(-\lambda t) \equiv 1-\sum _ {n=0}^{\infty}\frac{(-\lambda)^n t^n}{n!}, t \geq 0 $$
则称非负随机变量Ｘ服从指数分布。其中 $\lambda$ 是正实数，将Ｘ称为参数为 $\lambda $ 的指数随机变量。
取分布函数 F(t) 的导数，即得到指数分布的概率密度函数：
$$ f(t)=\frac{dF(t)}{dt}=\lambda exp(- \lambda t), t \geq 0 $$
练习1.1.1： 式子 $$ \int _ {0} ^ {\infty} \lambda e ^ {- \lambda t} dt=1 $$ 使用了分部积分法，试着从概率上解释（不使用任何计算）为什么积分的结果是 1 。
图 1.1 绘制了 $\lambda = 1$ 和 $\lambda = 5$ 时的指数分布的概率密度函数，这两者表现出了类似“指数”的形状。
练习1.1.2： 分别绘制 $\lambda = 0.</description>
    </item>
    
    <item>
      <title>FMAM - 预备内容：指数分布和 Erlang 分布 - Chapter 1 </title>
      <link>https://chongg039.cn/post/fmam-prepare-2/</link>
      <pubDate>Tue, 17 Jul 2018 17:19:48 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/fmam-prepare-2/</guid>
      <description>泊松分布是离散变量的随机分布，发生的次数之间是离散的。指数分布则针对连续型随机变量定义，即时间必须是连续的。
指数分布可以用来表示独立随机事件发生的时间间隔，比如旅客进入机场的时间间隔、打进客服中心电话的时间间隔、中文维基百科新条目出现的时间间隔等等。 – wikipedia
粗略地可以认为这两个分布之间有一种“倒数”的关系。
指数分布概率密度函数：$$f(x)=\lambda e^{-\lambda x},x \in [0,+\infty)$$
其中 $\lambda &amp;gt;0$ 是分布的一个参数，常被称为率参数（rate parameter）。即每单位时间发生该事件的次数。
累积分布函数：$$P(X\leqslant x)=1- e^{-\lambda x},x \in [0,+\infty)$$
注意：若令$\theta = \frac{1}{\lambda}$，概率密度：$p=\frac{1}{\theta}e^{-x/\theta}$，分布函数：$P(X\leqslant x)=F(x)=1-e^{-x/\theta},x \in [0,+\infty)$
这个 $\lambda $ 就是泊松分布中的 $\lambda $，此时指数分布的期望就是 $EX=\theta \quad (\lambda=1/\theta)$ 。
指数分布的描述对象是“连续型随机变量”。指数分布是泊松过程的事件间隔的分布：泊松分布表示的是事件发生的次数，“次数”这个是离散变量，所以泊松分布是离散随机变量的分布；指数分布是两件事情发生的平均间隔时间，“时间”是连续变量，所以指数分布是一种连续随机变量的分布。
指数分布的实例：
 旅客进机场的时间间隔 网站访问的时间间隔 婴儿出生的时间间隔  泊松分布是单位时间内独立事件发生次数的概率分布，指数分布是独立事件的时间间隔的概率分布。注两者的前提的前提是”独立事件”，事件之间不能有关联。
爱尔朗分布（Erlang Distribution）是一种连续型概率分布，该分布与指数分布一样多用来表示独立随机事件发生的时间间隔。相比于指数分布，爱尔朗分布能更好地对现实数据进行拟合（更适用于多个串行过程，或无记忆性假设不显著的情况下）。除非退化为指数分布，爱尔朗分布不具有无记忆性（或马尔可夫性质），因此对其进行分析相对困难一些。一般通过将爱尔朗过程分解为多个指数过程的技巧来对爱尔朗分布进行分析。
遵循爱尔朗分布的随机变量可以被分解多个同参数指数分布随机变量之和，该性质使得爱尔朗分布被广泛用于排队论中。
爱尔朗分布有两个参数，阶数（stage）$k$ 和均值 $\mu$ （也有用 $\lambda ={\frac {1}{\mu }}$ 来代替的）。具有阶数 $k$ 的爱尔朗过程被称为k阶爱尔朗（k-stage Erlang），对应的随机变量可被视为k个独立同参数指数分布随机变量之和。
依据上下文环境不同，均值参数 $\mu$ 可以指整个爱尔朗分布的均值 $\mu _ {0}$ 也可以指每个指数分布的均值 $\mu _ {i}$ 。两者的关系是： $$\mu _ {i}={\frac {\mu _ {0}}{k}}$$</description>
    </item>
    
    <item>
      <title>FMAM - 预备内容：从泊松分布到泊松过程 - Chapter 1</title>
      <link>https://chongg039.cn/post/fmam-prepare-1/</link>
      <pubDate>Mon, 16 Jul 2018 09:33:33 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/fmam-prepare-1/</guid>
      <description>泊松分布 泊松分布由二项分布演变而来。二项分布：
事件 A 在一次实验中发生的概率为 P ，将这个实验独立地重复 n 次，即做 n 次独立重复的伯努利实验，在这 n 次实验中事件A发生的次数记为 x ，概率有：
$$P(x=k)=C _ {n}^{k}p^{k}(1-p)^{n-k}$$，记为 $X\sim B(n,p)$ ，期望 $E=pn$
认为在 n 趋于无穷大时，p 为无穷小，期望值不变为一常数，记 $E=pn=\lambda$
即：$$p=\frac{\lambda}{n}$$，则当 $n \to +\infty$ 时，P 将趋于泊松分布：$$P(x=k)= e^{-\lambda}\frac{\lambda^{k}}{k!}$$
期望和方差都是 $\lambda$ ，$\lambda$ 表示一段时间内事件发生的次数。
泊松分布实例：
 一本书里，印刷错误的字的个数 一段时间内的次品率 某医院平均每小时出生的婴儿数 某网站每分钟的访问次数  独立增量过程 亦称可加过程（additive process)，是在不相交时段上增量相互独立的随机过程。
考虑实值过程 $$ X _ {t}, t \in T $$
如果对于任意参数 $$ t _ {0} &amp;lt; t _ {1} &amp;lt; &amp;hellip; t _ {n} $$</description>
    </item>
    
    <item>
      <title>Fundamentals of Matrix-Analytic Methods 学习笔记 -- 开坑篇</title>
      <link>https://chongg039.cn/post/fmam-start/</link>
      <pubDate>Thu, 12 Jul 2018 11:19:49 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/fmam-start/</guid>
      <description>教研室老板要求学习 Qi-Ming He 老师的这本书 Fundamentals of Matrix-Analytic Methods，于是准备开一个新坑，翻译一下这本书的关键内容，做做笔记，并对一些预备内容（概率分布、矩阵分析等）作解读。
文章的标题格式为“书名简称” + “中文章节名”，笔记将穿插在其中以代码块或其他形式存在。预备内容标题格式为“书名简称” + “预备内容：标题” + “大致章节名”。
以此来督促自己研究生期间好好学习。</description>
    </item>
    
    <item>
      <title>从 Reddit 愚人节像素大战说起</title>
      <link>https://chongg039.cn/post/2017-reddit-place/</link>
      <pubDate>Mon, 10 Apr 2017 23:01:33 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/2017-reddit-place/</guid>
      <description>&lt;p&gt;愚人节当天，我因为打球扭伤了自己的脚踝。那两天躺在床上无聊之余翻到了霍老师的一篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://mp.weixin.qq.com/s/Pz0NZ2t9fd_-RNFj1rT0hA&#34;&gt;《参与这场线上大战之后，我觉得人类未来还是有希望的》&lt;/a&gt;     (公众号：歪理邪说)&lt;/p&gt;
&lt;p&gt;这篇文章让我产生了极大的兴趣，立刻忍着疼痛抱来了电脑，登上了 Reddit 参与了这场线上大战。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 Cloudflare 为自定义域名的 Github 博客完成全站 HTTPS 化</title>
      <link>https://chongg039.cn/post/all-https/</link>
      <pubDate>Wed, 22 Mar 2017 22:51:09 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/all-https/</guid>
      <description>&lt;p&gt;跟风，响应 Web 世界的号召，决定把博客全站换成 HTTPS 访问，并记录下遇到的一些问题。&lt;/p&gt;
&lt;h3 id=&#34;github-page&#34;&gt;Github Page&lt;/h3&gt;
&lt;p&gt;原来博客是部署在云服务器上，后来觉得没有这个必要，也不想花精力在维护上面，就重新把博客放回了 Github Page 。因此下面的文字并不针对自有服务器的博客用户进行说明。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>解决 Go 中遍历 map 的随机化问题</title>
      <link>https://chongg039.cn/post/map-in-order/</link>
      <pubDate>Mon, 13 Mar 2017 18:51:20 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/map-in-order/</guid>
      <description>&lt;p&gt;在 air-server 中有一个函数，支持解析 URL 的 query 并返回字段中城市的数据，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET /aqi/cities?1=成都&amp;amp;2=北京&amp;amp;3=杭州&amp;amp;4=西安
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;客户端希望的返回值应该是按照输入顺序，即 1，2，3，4 返回的，但实际多次测试后得到的结果总会是不一样的顺序。想了想应该是 query 解析的结果，即&lt;code&gt;r.URL.Query()&lt;/code&gt;为 map 的原因。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go实现空气质量状况API服务器过程中的思考</title>
      <link>https://chongg039.cn/post/aqi-server-in-go/</link>
      <pubDate>Sat, 04 Mar 2017 16:27:52 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/aqi-server-in-go/</guid>
      <description>&lt;p&gt;学习Go之后第一个项目，是编写一个API服务器，提供城市AQI的JSON数据。&lt;/p&gt;
&lt;p&gt;既然要实现这个功能，要解决的问题一个是数据源，一个是Server。&lt;/p&gt;
&lt;p&gt;先说说数据源，如果仅仅和我们初步设想的一样，仅仅为我们的一款应用提供即时数据，那样只是做一个第三方数据的中转便可。不过为了以后可以针对性的做数据分析，还是需要将数据爬下来存在数据库。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我为什么选择Go</title>
      <link>https://chongg039.cn/post/why-i-choose-go/</link>
      <pubDate>Mon, 27 Feb 2017 12:50:39 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/why-i-choose-go/</guid>
      <description>&lt;p&gt;是的，我开始接触go语言了，如去年年底所说的那样。&lt;/p&gt;
&lt;p&gt;先说说我为什么不继续用Node，并不是因为这门语言不好。事实上，NodeJS作为一个争议颇多的“全栈”语言，才带我真正走进了编程世界。它的异步，并发，非阻塞，以及丰富的npm库，无一不证明了它在解决传统服务器端编程的很多非常棒的思想。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2016年终总结</title>
      <link>https://chongg039.cn/post/2016-summary/</link>
      <pubDate>Sat, 31 Dec 2016 16:59:03 -0700</pubDate>
      
      <guid>https://chongg039.cn/post/2016-summary/</guid>
      <description>&lt;p&gt;年底了，总结一下这一年。&lt;/p&gt;
&lt;h4 id=&#34;工作室&#34;&gt;工作室&lt;/h4&gt;
&lt;p&gt;这一年有大半时间都是在创萌工作室度过的，也见证了创萌从当时的三五个人到现在的规模。&lt;/p&gt;
&lt;p&gt;工作室的巨总和迪哥算是我的导师。迪哥带着我从前端转向了nodejs，教会我如何作为一名全栈工程师来思考问题。而巨总眼界比较开阔，给我的更多是学习方法和技术趋势的指导。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 nodejs 模拟登陆电子科大信息门户并抓取信息</title>
      <link>https://chongg039.cn/post/mockland-uestc/</link>
      <pubDate>Thu, 08 Dec 2016 12:09:31 -0700</pubDate>
      
      <guid>https://chongg039.cn/post/mockland-uestc/</guid>
      <description>&lt;p&gt;学校高层做了个公众号，把信息门户弄到微信上的浏览器上。本着干掉学校高层的一贯行事风格，觉得是时候搞一个正规的公众号来抢学校生意了。&lt;/p&gt;
&lt;p&gt;结果没想到并不是很顺利，信息门户登录有两个重定向页面，自己也对模拟请求服务器不是很熟悉，一步一步好歹是扒到了想要的数据，也浪费了好长时间。先拿出来了个命令行版本，还停留在 es5，准备熬过去考试月后全部重构成 es6，再加上流程控制，放到公众号上造福社会。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux 服务器配置静态 IP 并 802.1x 拨号</title>
      <link>https://chongg039.cn/post/linux-server-staticip-8021x/</link>
      <pubDate>Sat, 12 Nov 2016 15:15:27 -0700</pubDate>
      
      <guid>https://chongg039.cn/post/linux-server-staticip-8021x/</guid>
      <description>&lt;p&gt;终于布好工作室的服务器了。&lt;/p&gt;
&lt;p&gt;我写了个脚本一键部署静态ip和802.1x拨号：&lt;a href=&#34;https://gist.github.com/chongg039/3310467e329e00de3b6b04aaae646f3c&#34;&gt;ubuntu-server.sh&lt;/a&gt;，不想看我啰嗦的可以直接拿过来改改就能用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用 vultr &#43; SS &#43; 锐速科学上网</title>
      <link>https://chongg039.cn/post/vultr-ss-serverspeed/</link>
      <pubDate>Mon, 03 Oct 2016 20:32:20 -0700</pubDate>
      
      <guid>https://chongg039.cn/post/vultr-ss-serverspeed/</guid>
      <description>&lt;p&gt;接手工作室后，tesths 便把原来那个已经配置好的ss账号连同服务器一块给销了。平时ss又十分必要，就向他讨要了具体的方法，自己搭了一个。这里也是把方法贴出来。&lt;/p&gt;
&lt;h3 id=&#34;配置vultr主机&#34;&gt;配置vultr主机&lt;/h3&gt;
&lt;p&gt;V家的主机算得上是性价比较高的一款了，而且有日本和新加坡的线路，相对来说延迟比较稳定。截止我购买的时候是每个新用户有20刀的返利，还是比较划算的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>解决 ubuntu 下键盘错位问题</title>
      <link>https://chongg039.cn/post/ubuntu-keyboard-error/</link>
      <pubDate>Sun, 02 Oct 2016 15:43:36 -0700</pubDate>
      
      <guid>https://chongg039.cn/post/ubuntu-keyboard-error/</guid>
      <description>&lt;p&gt;很悲催的键盘错位了，就这个系统有问题，以前也没遇到过。简而言之就是@和“互换，#打不出来等。问题不大，但是影响输入体验。
工作室的小伙伴都说我这电脑只有我会用。。。&lt;/p&gt;
&lt;p&gt;之前在网上搜到的解决办法是在终端输入：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo dpkg-reconfigure keyboard-configuration
//需要安装keyboard-configuration&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>使用ngrok实现内网穿透</title>
      <link>https://chongg039.cn/post/ngrok/</link>
      <pubDate>Sun, 18 Sep 2016 09:37:45 -0700</pubDate>
      
      <guid>https://chongg039.cn/post/ngrok/</guid>
      <description>&lt;p&gt;今天想用nodejs写一个微信公众号服务，很尴尬的发现自己的腾讯云学生服务器已经三个月没续费被收回了。工作室的这台服务器又不是很想动，于是就想到前一段时间看的一个实现内网穿透的工具ngrok，花了一段时间部署在了自己的ubuntu上。又化了两块钱买了个域名，准备以后作为工作室测试来用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>自用 Chrome 插件分享</title>
      <link>https://chongg039.cn/post/chrome-extensions/</link>
      <pubDate>Sat, 21 May 2016 15:45:01 -0700</pubDate>
      
      <guid>https://chongg039.cn/post/chrome-extensions/</guid>
      <description>&lt;p&gt;这里会持续不断分享一些自己觉的好用的 Chrome 插件，有些也会弃用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>搭建 Linux 开发环境</title>
      <link>https://chongg039.cn/post/build-ubuntu-environment/</link>
      <pubDate>Thu, 12 May 2016 19:29:07 -0700</pubDate>
      
      <guid>https://chongg039.cn/post/build-ubuntu-environment/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;先说说我为啥要干这事儿。
前段时间迪哥要我们用node搞一个最小化 MEAN 产品，没想到只是在搭建开发环境上windows就各种不兼容，出现了许多奇奇怪怪的bug，再加上国内关于node的开发教程确实相对比较少，没有好的学习资源。搞了virtualbox虚拟机，但是内存和性能又开始捉急。干脆换到ubuntu，一步到位，特此记录下过程。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>说说es5中的闭包</title>
      <link>https://chongg039.cn/post/talk-about-closure/</link>
      <pubDate>Mon, 18 Apr 2016 19:26:22 -0700</pubDate>
      
      <guid>https://chongg039.cn/post/talk-about-closure/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;匿名函数&lt;/strong&gt;：下面是最常见的一种&lt;strong&gt;函数表达式&lt;/strong&gt;的书写形式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;var functionName = function(arg0, arg1, arg2){
    //函数体
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即：创建一个函数，并将其复制给变量&lt;code&gt;functionName&lt;/code&gt;，这种情况下创建的函数叫做匿名函数(anonymous function)，&lt;strong&gt;因为&lt;/strong&gt;&lt;code&gt;function&lt;/code&gt;&lt;strong&gt;后面没有标识符&lt;/strong&gt;，其&lt;code&gt;name&lt;/code&gt;属性是空字符串。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>写在前面</title>
      <link>https://chongg039.cn/post/hello-world/</link>
      <pubDate>Sun, 17 Apr 2016 19:29:07 -0700</pubDate>
      
      <guid>https://chongg039.cn/post/hello-world/</guid>
      <description>&lt;h2 id=&#34;我为什么建博客&#34;&gt;我为什么建博客&lt;/h2&gt;
&lt;p&gt;大二本科加入创萌工作室学习前端，整个学习阶段对于笔记以及感悟的整理从印象，有道云转移到Quip，感觉最好还是有一个独立博客更为方便。在爬了两个星期的坑后使用Hexo+huno主题以及一些开源插件完成了整个博客的大致创建。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
