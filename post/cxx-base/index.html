<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>[基础知识]C&#43;&#43;基础知识汇总</title>
    <link rel="stylesheet" type="text/css" href="https://chongg039.cn/css/style.css" />
    
    <link rel="shortcut icon" href="https://chongg039.cn/img/favicon.ico">
    <link rel="stylesheet" type="text/css" href="https://chongg039.cn/css/sunburst.css" />
</head>
<body onload="PR.prettyPrint()">
    <div class="navheader">
        <table width="100%" summary="Navigation header">
            <tbody>
                <tr>
                    <td colspan="3" align="center">Co1driver 的个人博客</td>
                </tr>
                <tr>
                    <td width="90%" align="left">&nbsp;</td>
                    <td width="5%" align="center">&nbsp;<a accesskey="h" href="https://github.com/chongg039">GITHUB</a></td>
                    <td width="5%" align="right">&nbsp;<a accesskey="a" href="https://chongg039.cn//about">ABOUT</a></td>
                </tr>
            </tbody>
        </table>
    </div>

    <h1>[基础知识]C&#43;&#43;基础知识汇总</h1>
    <h4>Sun, Oct 20, 2019</h4>
    <h3 id="指针和引用">指针和引用</h3>
<h4 id="联系">联系</h4>
<p>C++底层中引用是通过指针实现的，在实现层面上引用就是指针，指向同一对象的内存地址。</p>
<p>所有对引用的操作就是对原始对象的操作。</p>
<h4 id="区别">区别</h4>
<ol>
<li>引用只是别名，不是实体类型，因此编译器不为引用分配单独的内存空间，而指针有自己的内存空间，因此某种程度上指针不能被引用取代；</li>
<li>引用必须被初始化且不能为空，但可以有未初始化的空指针；</li>
<li>引用一旦初始化就不能更换目标，即不能被初始化多次，指针可以更改指向的对象；</li>
<li>可以有指针数组，不能有引用数组，因为引用没有被分配内存；</li>
<li>当引用作为函数的形参时，因为函数形参和实参是同一个对象，避免了复制对象的开销；</li>
<li>若对引用型参数做const修饰，则不会调用拷贝构造函数，提高效率；</li>
<li>若引用作为函数的返回结果，需要保证函数返回后被引用的目标一直有效，即不能返回函数内部的局部对象的引用（因为离开作用域后会被析构掉）。</li>
</ol>
<h3 id="数组和指针">数组和指针</h3>
<p>C++不记录数组本身的大小，因此一定注意不要越界访问。</p>
<p>数组作为形参传递时会退化为同类型的指针：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> data[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>};
<span style="color:#66d9ef">int</span> size1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(data); <span style="color:#75715e">// 20
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>data2 <span style="color:#f92672">=</span> data;
<span style="color:#66d9ef">int</span> size2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(data2); <span style="color:#75715e">// 4
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetSize</span>(<span style="color:#66d9ef">int</span> data[])
{
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">sizeof</span>(data);
}
<span style="color:#66d9ef">int</span> size3 <span style="color:#f92672">=</span> GetSize(data); <span style="color:#75715e">// 4
</span></code></pre></div><h3 id="sizeof使用与陷阱">sizeof使用与陷阱</h3>
<p><a href="https://www.cnblogs.com/chio/archive/2007/06/11/778934.html">https://www.cnblogs.com/chio/archive/2007/06/11/778934.html</a></p>
<h3 id="内存对齐">内存对齐</h3>
<p>尽管计算机中内存是按照字节byte划分的，但不是寻址可以从任意的byte开始。一般来说计算机会对基本数据类型数据在内存中存放的位置加以限制，要求首地址必须是某个数（一般是4和8）的倍数，这就是内存对齐。</p>
<p>因为虽然计算机按照字节划分存储空间，但处理器存取一次内存不是按照一个字节存取的，一般以双字节、4字节、8字节甚至到32字节存取。这被称为内存存取粒度。</p>
<p>对32位处理器的int类型（4字节），若数据现在可以存放在任一字节开始处，会产生性能的损失。比如，现在从地址1字节开始存放int（1-5，左开右闭），读取时从0字节开始读取一个4字节大小的块，需要访问两次内存。第一步先读取0-4左开右闭字节快，剔除0地址字节；第二步访问4-8左开右闭字节快，剔除5、6、7三个字节块。然后将这两部分得到的合并放入寄存器，需要做很多工作。有了内存对齐，那么只能从规定的边界存放和读取，访问一次内存就可以了。</p>
<p>设置编译器的”对齐系数(对齐模数)“的预处理指令为#pragma pack(n)，linux下gcc默认n=4。还有一个概念为”对齐单位“，也称有效对齐值，是指n和结构体中最长数据类型（基本数据类型）长度中较小的那一个值。</p>
<p>下面说一下内存对齐规则，主要有两条：</p>
<ol>
<li>结构体中第一个成员的offset为0，之后每个成员都相对首地址的offset都是”该成员大小“和”对齐单位“中较小的那个的整数倍。如有需要可以添加进填充字节；</li>
<li>结构体的总大小为”对齐单位“的整数倍，如有需要会在最末尾成员添加填充字节。</li>
</ol>
<p>分析下下面三个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#</span><span style="color:#75715e">pragma pack(4)</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">// 先使用第一条规则
</span><span style="color:#75715e"></span><span style="color:#75715e">//  对x, 对齐单位min(4, 4) = 4, 按照4字节对齐, 不用偏移, 从0开始占用4个字节
</span><span style="color:#75715e"></span><span style="color:#75715e">//  对c1, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从4开始占用1个字节
</span><span style="color:#75715e"></span><span style="color:#75715e">//  对c2, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从5开始占用1个字节
</span><span style="color:#75715e"></span><span style="color:#75715e">// 再使用第二条规则, 结构体大小需要是对齐单位的整数倍, 补2个字节在末尾
</span><span style="color:#75715e"></span><span style="color:#75715e">// sizeof(x1) = 8
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">x1</span>
{
    <span style="color:#66d9ef">int</span> x;
    <span style="color:#66d9ef">char</span> c1;
    <span style="color:#66d9ef">char</span> c2;
} x1;

<span style="color:#75715e">// 先使用第一条规则
</span><span style="color:#75715e"></span><span style="color:#75715e">//  对c1, 对齐单位min(4, 1) = 1, 按照1字节对齐, 不用偏移, 从0开始占用1个字节
</span><span style="color:#75715e"></span><span style="color:#75715e">//  对c2, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从1开始占用1个字节
</span><span style="color:#75715e"></span><span style="color:#75715e">//  对x, 对齐单位min(4, 4) = 4, 按照4字节对齐, 相对于首地址偏移min(4, 4) = 4的倍数, 需要先填充2位, 再从4开始占用4个字节
</span><span style="color:#75715e"></span><span style="color:#75715e">// 再使用第二条规则, 结构体大小需要是对齐单位的整数倍, 不用补填充字节
</span><span style="color:#75715e"></span><span style="color:#75715e">// sizeof(x2) = 8
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">x2</span>
{
    <span style="color:#66d9ef">char</span> c1;
    <span style="color:#66d9ef">char</span> c2;
    <span style="color:#66d9ef">int</span> x;
} x2;

<span style="color:#75715e">// 先使用第一条规则
</span><span style="color:#75715e"></span><span style="color:#75715e">//  对c1, 对齐单位min(4, 1) = 1, 按照1字节对齐, 不用偏移, 从0开始占用1个字节
</span><span style="color:#75715e"></span><span style="color:#75715e">//  对x, 对齐单位min(4, 4) = 4, 按照4字节对齐, 相对于首地址偏移min(4, 4) = 1的倍数, 需要先填充3位, 再从4开始占用4个字节
</span><span style="color:#75715e"></span><span style="color:#75715e">//  对c2, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从8开始占用1个字节
</span><span style="color:#75715e"></span><span style="color:#75715e">// 再使用第二条规则, 结构体大小需要是对齐单位的整数倍, 补3个字节在末尾
</span><span style="color:#75715e"></span><span style="color:#75715e">// sizeof(x3) = 12
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">x3</span>
{
    <span style="color:#66d9ef">char</span> c1;
    <span style="color:#66d9ef">int</span> x;
    <span style="color:#66d9ef">char</span> c2;
} x3;
<span style="color:#75715e">#</span><span style="color:#75715e">pragma pack()</span><span style="color:#75715e">
</span></code></pre></div><p>准确地讲这是属于内存的字节对齐。还有一个问题是大端对齐和小端对齐，这和处理器的架构有关系。大端对齐模式就是数据的低位保存在内存的高地址，内存的低地址存放着数据的高位。小端对齐模式就是数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。一般都是使用小端对齐的方式，大端对齐主要用在一些大型机的处理器中。</p>
<h3 id="多态">多态</h3>
<p>重载overload，重写override，重定义overwrite</p>
<pre><code>重载：函数名相同，函数的参数个数、参数类型或参数顺序三者中必须至少有一种不同。函数返回值的类型可以相同，也可以不相同。发生在一个类内部。

重写：也叫做覆盖，一般发生在子类和父类继承关系之间。子类重新定义父类中有相同名称和参数的虚函数。(override)

重定义：也叫做隐藏，子类重新定义父类中有相同名称的非虚函数(参数列表可以不同)，指派生类的函数屏蔽了与其同名的基类函数。可以理解成发生在继承中的重载。
</code></pre>
    
    
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: '36c8fa6e09d08297a270',
    clientSecret: 'af0175944284956d288d14b389fbc89be8df7f1e',
    repo: 'chongg039.github.io',
    owner: 'chongg039',
    admin: ['chongg039'],
    id: location.pathname, 
    distractionFreeMode: false 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>

<div class="navfooter">
    <table width="100%" summary="Navigation footer">
        <tbody>
            <tr>
                <td width="40%" align="left">&nbsp;</td>
                <td width="20%" align="center">&nbsp;</td>
                <td width="40%" align="right">&nbsp;</td>
            </tr>
            <tr>
                <td width="40%" align="left" valign="top">
                    <span class="copyright">
                        Copyright 2014-2020
                    </span>
                    &nbsp;
                </td>
                <td width="20%" align="center">&nbsp;</td>
                <td width="40%" align="right" valign="top">&nbsp;<a href="https://chongg039.cn/">HOME</a></td>
            </tr>
        </tbody>
    </table>
</div>
</body>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: { 
            inlineMath: [ ['$','$'], ['\\(','\\)'] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true
        }
    });
    </script>
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-117991024-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    <script type="text/javascript" src="https://chongg039.cn/js/function.js"></script>
    <script type="text/javascript" src="https://chongg039.cn/js/prettify.js"></script>
    
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
</html>

