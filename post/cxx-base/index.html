<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>[基础知识]C&#43;&#43;基础知识汇总</title>
    <link rel="stylesheet" type="text/css" href="https://chongg039.cn/css/style.css" />
    
    <link rel="shortcut icon" href="https://chongg039.cn/img/favicon.ico">
    <link rel="stylesheet" type="text/css" href="https://chongg039.cn/css/sunburst.css" />
</head>
<body onload="PR.prettyPrint()">
    <div class="navheader">
        <table width="100%" summary="Navigation header">
            <tbody>
                <tr>
                    <td colspan="3" align="center">Co1driver 的个人博客</td>
                </tr>
                <tr>
                    <td width="85%" align="left">&nbsp;</td>
                    <td width="5%" align="center">&nbsp;<a accesskey="h" href="https://github.com/chongg039">GITHUB</a></td>
                    <td width="5%" align="center">&nbsp;<a accesskey="a" href="https://chongg039.cn//photo">PHOTO</a></td>
                    <td width="5%" align="right">&nbsp;<a accesskey="a" href="https://chongg039.cn//about">ABOUT</a></td>
                </tr>
            </tbody>
        </table>
    </div>

    <h1>[基础知识]C&#43;&#43;基础知识汇总</h1>
    <h4>Sun, Oct 20, 2019</h4>
    <h3 id="指针和引用">指针和引用</h3>
<h4 id="联系">联系</h4>
<p>C++底层中引用是通过指针实现的，在实现层面上引用就是指针，指向同一对象的内存地址。</p>
<p>所有对引用的操作就是对原始对象的操作。</p>
<h4 id="区别">区别</h4>
<ol>
<li>引用只是别名，不是实体类型，因此编译器不为引用分配单独的内存空间，而指针有自己的内存空间，因此某种程度上指针不能被引用取代；</li>
<li>引用必须被初始化且不能为空，但可以有未初始化的空指针；</li>
<li>引用一旦初始化就不能更换目标，即不能被初始化多次，指针可以更改指向的对象；</li>
<li>可以有指针数组，不能有引用数组，因为引用没有被分配内存；</li>
<li>当引用作为函数的形参时，因为函数形参和实参是同一个对象，避免了复制对象的开销；</li>
<li>若对引用型参数做const修饰，则不会调用拷贝构造函数，提高效率；</li>
<li>若引用作为函数的返回结果，需要保证函数返回后被引用的目标一直有效，即不能返回函数内部的局部对象的引用（因为离开作用域后会被析构掉）。</li>
</ol>
<h3 id="数组和指针">数组和指针</h3>
<p>C++不记录数组本身的大小，因此一定注意不要越界访问。</p>
<p>数组作为形参传递时会退化为同类型的指针：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> data[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>};
<span style="color:#66d9ef">int</span> size1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(data); <span style="color:#75715e">// 20
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>data2 <span style="color:#f92672">=</span> data;
<span style="color:#66d9ef">int</span> size2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(data2); <span style="color:#75715e">// 4
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetSize</span>(<span style="color:#66d9ef">int</span> data[])
{
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">sizeof</span>(data);
}
<span style="color:#66d9ef">int</span> size3 <span style="color:#f92672">=</span> GetSize(data); <span style="color:#75715e">// 4
</span></code></pre></div><h3 id="sizeof使用与陷阱">sizeof使用与陷阱</h3>
<p><a href="https://www.cnblogs.com/chio/archive/2007/06/11/778934.html">https://www.cnblogs.com/chio/archive/2007/06/11/778934.html</a></p>
<h3 id="内存对齐">内存对齐</h3>
<p>尽管计算机中内存是按照字节byte划分的，但不是寻址可以从任意的byte开始。一般来说计算机会对基本数据类型数据在内存中存放的位置加以限制，要求首地址必须是某个数（一般是4和8）的倍数，这就是内存对齐。</p>
<p>因为虽然计算机按照字节划分存储空间，但处理器存取一次内存不是按照一个字节存取的，一般以双字节、4字节、8字节甚至到32字节存取。这被称为内存存取粒度。</p>
<p>对32位处理器的int类型（4字节），若数据现在可以存放在任一字节开始处，会产生性能的损失。比如，现在从地址1字节开始存放int（1-5，左开右闭），读取时从0字节开始读取一个4字节大小的块，需要访问两次内存。第一步先读取0-4左开右闭字节快，剔除0地址字节；第二步访问4-8左开右闭字节快，剔除5、6、7三个字节块。然后将这两部分得到的合并放入寄存器，需要做很多工作。有了内存对齐，那么只能从规定的边界存放和读取，访问一次内存就可以了。</p>
<p>设置编译器的”对齐系数(对齐模数)“的预处理指令为#pragma pack(n)，一般32位系统下对齐系数为n=4，64位系统下对齐系数为n=8。还有一个概念为”对齐单位“，也称有效对齐值，是指n和结构体中最长数据类型（基本数据类型）长度中较小的那一个值。</p>
<p>下面说一下内存对齐规则，主要有两条：</p>
<ol>
<li>结构体中第一个成员的offset为0，之后每个成员都相对首地址的offset都是”该成员大小“和”对齐单位“中较小的那个的整数倍。如有需要可以添加进填充字节；</li>
<li>结构体的总大小为”对齐单位“的整数倍，如有需要会在最末尾成员添加填充字节。</li>
</ol>
<p>分析下下面三个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#pragma pack(4)
</span><span style="color:#75715e"></span><span style="color:#75715e">// 先使用第一条规则
</span><span style="color:#75715e">//  对x, 对齐单位min(4, 4) = 4, 按照4字节对齐, 不用偏移, 从0开始占用4个字节
</span><span style="color:#75715e">//  对c1, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从4开始占用1个字节
</span><span style="color:#75715e">//  对c2, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从5开始占用1个字节
</span><span style="color:#75715e">// 再使用第二条规则, 结构体大小需要是对齐单位的整数倍, 补2个字节在末尾
</span><span style="color:#75715e">// sizeof(x1) = 8
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">x1</span>
{
    <span style="color:#66d9ef">int</span> x;
    <span style="color:#66d9ef">char</span> c1;
    <span style="color:#66d9ef">char</span> c2;
} x1;

<span style="color:#75715e">// 先使用第一条规则
</span><span style="color:#75715e">//  对c1, 对齐单位min(4, 1) = 1, 按照1字节对齐, 不用偏移, 从0开始占用1个字节
</span><span style="color:#75715e">//  对c2, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从1开始占用1个字节
</span><span style="color:#75715e">//  对x, 对齐单位min(4, 4) = 4, 按照4字节对齐, 相对于首地址偏移min(4, 4) = 4的倍数, 需要先填充2位, 再从4开始占用4个字节
</span><span style="color:#75715e">// 再使用第二条规则, 结构体大小需要是对齐单位的整数倍, 不用补填充字节
</span><span style="color:#75715e">// sizeof(x2) = 8
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">x2</span>
{
    <span style="color:#66d9ef">char</span> c1;
    <span style="color:#66d9ef">char</span> c2;
    <span style="color:#66d9ef">int</span> x;
} x2;

<span style="color:#75715e">// 先使用第一条规则
</span><span style="color:#75715e">//  对c1, 对齐单位min(4, 1) = 1, 按照1字节对齐, 不用偏移, 从0开始占用1个字节
</span><span style="color:#75715e">//  对x, 对齐单位min(4, 4) = 4, 按照4字节对齐, 相对于首地址偏移min(4, 4) = 1的倍数, 需要先填充3位, 再从4开始占用4个字节
</span><span style="color:#75715e">//  对c2, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从8开始占用1个字节
</span><span style="color:#75715e">// 再使用第二条规则, 结构体大小需要是对齐单位的整数倍, 补3个字节在末尾
</span><span style="color:#75715e">// sizeof(x3) = 12
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">x3</span>
{
    <span style="color:#66d9ef">char</span> c1;
    <span style="color:#66d9ef">int</span> x;
    <span style="color:#66d9ef">char</span> c2;
} x3;
<span style="color:#75715e">#pragma pack()
</span></code></pre></div><p>准确地讲这是属于内存的字节对齐。还有一个问题是大端对齐和小端对齐，这和处理器的架构有关系。大端对齐模式就是数据的低位保存在内存的高地址，内存的低地址存放着数据的高位。小端对齐模式就是数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。一般都是使用小端对齐的方式，大端对齐主要用在一些大型机的处理器中。</p>
<h3 id="多态">多态</h3>
<p>重载overload，重写override，重定义overwrite</p>
<pre><code>重载：函数名相同，函数的参数个数、参数类型或参数顺序三者中必须至少有一种不同。函数返回值的类型可以相同，也可以不相同。发生在一个类内部。

重写：也叫做覆盖，一般发生在子类和父类继承关系之间。子类重新定义父类中有相同名称和参数的虚函数。(override)

重定义：也叫做隐藏，子类重新定义父类中有相同名称的非虚函数(参数列表可以不同)，指派生类的函数屏蔽了与其同名的基类函数。可以理解成发生在继承中的重载。
</code></pre><p>多态主要指静态多态和动态多态。静态多态就是函数重载，也包含函数模板和类模板的参数多态性，在编译期完成；动态多态是在程序运行时根据基类的指针或引用指向的对象来确定自己具体该调用哪一个类的虚函数，在运行期确定。</p>
<p>构造函数不能被virtual修饰，基类的析构函数有必要声明为virtual，否则子类析构不能被正确调用。**将基类的析构函数声明为虚函数后，派生类的析构函数也会自动成为虚函数。**static成员函数不能声明为虚函数，因为它属于类而不属于某个对象。在C++11中，被final修饰的虚函数不能被子类重写。</p>
<p>构造函数不能是虚函数。而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被disable的。 析构函数可以是纯虚的，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。</p>
<p>virtual + &quot; = 0&quot;形式上告诉了编译器这是一个纯虚函数，包含纯虚函数的类不能被实例化。对于纯虚析构函数，正常情况下子类是不能被实例化的，因为子类在析构时会调用基类的析构函数，而基类的析构函数纯虚，没有一个默认的实现，此时会报出链接错误。但事实上，一个纯虚析构函数我们仍可为其指定一个实现，这样子类的在析构时只会调用自己的析构函数。虽然看起来有些奇怪，但编译器并不会对此抱怨什么，不过很显然这里的实现就不能写成inline的了。<strong>上面说明了：可以有纯虚析构函数，但是必须有定义体。</strong></p>
<p>为什么编译器可以在运行时通过指针指向的对象找到虚函数？如果一个类包含虚函数，编译器在编译阶段会额外增加一个数组，数组中的每个元素都是虚函数的入口地址。这个数组就是虚函数表vtable。虚函数表是属于类的，不属于任何一个对象。在代码的编译阶段这个虚函数表就可以构造出来。</p>
<p>为了将实例化的对象和虚函数表关联起来，编译器在带有虚函数的对象中插入了一个指针vfptr，指向对应类的虚函数表的起始位置，这就是相似的带有虚函数的对象要比不带虚函数的对象要大的原因。同一个类的所有对象使用同一份虚函数表。注意，若一个类的基类包含虚函数，那这个类也拥有自己的虚表，类的对象拥有一个指向这个虚表的虚表指针。</p>
<p>vfptr的分步初始化：在构造子类对象时，执行父类构造函数时，子类的vfptr指针指向父类的虚函数表，当父类构造函数执行完毕后，子类的vfptr会指向子类的虚函数表。</p>
<p>关于动态绑定可以看这个<a href="https://blog.csdn.net/lihao21/article/details/50688337">博客</a>。</p>
<p>对于单继承的情况：</p>
<ol>
<li>基类的虚函数在vtable中的索引（下标）是固定的，不会随着继承层次的增加而改变，派生类新增的虚函数放在vtable的最后；</li>
<li>如果派生类有同名的虚函数override了基类的虚函数，那么将使用派生类的虚函数替换基类的虚函数，这样具有override关系的虚函数在vtable中只会出现一次；</li>
<li>当通过指针调用虚函数时，先根据指针找到vfptr，再根据vfptr找到虚函数的入口地址；对于不同的虚函数，仅仅改变索引（下标）即可。</li>
</ol>
<h4 id="插一句对象大小的计算">插一句对象大小的计算</h4>
<ol>
<li>非虚成员函数、静态成员函数、静态成员变量、静态常量成员变量均不影响对象的内存大小；</li>
<li>虚函数影响对象大小，因为虚函数表指针；</li>
<li>虚继承影响对象大小，因为虚基表指针；</li>
<li>空类对象大小为1，空类是指既没有非静态数据成员，也没有虚函数，也不存在虚继承；</li>
<li>继承一个空类有两种情况：一是派生类也是空类，派生类大小也为1；二是派生类不是空类，注意此时基类的一个字节大小并不会算进派生类的内存空间当中；</li>
<li>包含一个空类，此时派生类的内存空间将包含这一个字节的大小（最终计算不要忘记考虑字节对齐）。</li>
</ol>
<h4 id="普通多继承菱形继承和虚继承">普通多继承、菱形继承和虚继承</h4>
<p>有两个分属与不同集成体系的基类B1和B2，派生类同时继承这两个基类，这就是普通的多继承。由于多个基类分属不同的继承体系，一般不会出现什么问题，尽管不提倡使用多继承。</p>
<p>菱形继承怎么产生的呢，看一张来自Wikipedia图片：</p>
<p><img src="https://cdn.jsdelivr.net/gh/chongg039/blog-pic-repo@master/uPic/yr9Dxf.jpg#center" alt="yr9Dxf"></p>
<p>这会带来以下两个问题：</p>
<ol>
<li>若A中有非静态成员变量x，那么在D中最终将有两个x，不仅增大了内存，使用x也会产生二义性问题；</li>
<li>若A中有一个成员函数，D调用该成员函数会产生二义性。若B和C中定义了同名（参数表可以不同）的两个成员函数，调用某一个也会产生二义性；</li>
</ol>
<p>先看普通的菱形继承的内存占用大小，在我的64位系统上对齐系数是8bytes：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    A() <span style="color:#f92672">:</span> a_(<span style="color:#ae81ff">0</span>)
    {};

    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>A() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> a_;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    B() <span style="color:#f92672">:</span> b_(<span style="color:#ae81ff">1</span>)
    {};
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> b_;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    C() <span style="color:#f92672">:</span> c_(<span style="color:#ae81ff">1</span>)
    {};
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> c_;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> B, <span style="color:#66d9ef">public</span> C
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    D() <span style="color:#f92672">:</span> d_(<span style="color:#ae81ff">2</span>)
    {};
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> d_;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(A) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 16
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(B) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 16
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(C) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 16
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(D) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 36/40
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>64位系统上int占4bytes，一个虚函数表指针占8bytes，最终A占用大小为12，算上8bytes对齐就是16；对于B，成员b_和a_各占4bytes，很幸运的不需要填充字节，然后因为里面有个继承来的虚函数，虚表指针占用8bytes，最终大小是16（如果不相信，可以将对齐系数改为4做个对比验证）；C和B的情况一样；对于D，情况有些特殊，计算方式为：</p>
<pre><code>4(d_) + 4(c_) + 4(b_) + 4(a_) + 4(a_) + 8(vfptr) + 8(vfptr) + 4(尾字节对齐)= 40
</code></pre><p>很显然，前面说过D中会有A中数据成员的两分拷贝。又因为D继承B、C两个分支，所以会有两个虚函数表指针。在这里说明一下，**带有虚函数的类，其大小和虚函数的个数无关，只与虚函数表指针的个数有关。**对于A，写再多的虚函数，虚函数表指针也只有一个。</p>
<p>一个解决方案是使用using限定作用域来达到消歧的目的，但永远不会是最优。菱形继承问题引出了使用虚继承的解决方案：如果类B与C各自虚继承了类A，那么D的对象就只包含一套类A的实例数据。这一特性在多重继承应用中非常有用，可以使得虚基类对于由它直接或间接派生的类来说，拥有一个共同的基类对象实例。间接派生类D穿透了其父类B、C，实质上直接继承了虚基类A。</p>
<p>再看看使用了虚继承后内存占用的大小，还是8bytes对齐：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    A() <span style="color:#f92672">:</span> a_(<span style="color:#ae81ff">0</span>)
    {};

    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>A() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> a_;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span> A
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    B() <span style="color:#f92672">:</span> b_(<span style="color:#ae81ff">1</span>)
    {};
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> b_;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span> A
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    C() <span style="color:#f92672">:</span> c_(<span style="color:#ae81ff">1</span>)
    {};
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> c_;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> B, <span style="color:#66d9ef">public</span> C
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    D() <span style="color:#f92672">:</span> d_(<span style="color:#ae81ff">2</span>)
    {};
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> d_;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(A) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 16
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(B) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 32
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(C) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 32
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(D) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 48
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>对A没什么好说的，还是一样；对B，现在的计算方式为：</p>
<pre><code>4(b_) + 4(a_) + 8(vfptr) + 8(vbptr) = 24
</code></pre><p>这个vbptr就是虚基类表指针。至于为什么最终结果是32，我想是由于内存中存放顺序的原因，一般来说会先将两个虚表指针放在低位，再将数据成员放在后面，这样就会由于8bytes对齐导致填充字节后的最终结果是32。若将对齐系数改为4，最终大小就是24了。对于C，情况和B一样。</p>
<p>对于D，现在应该这样计算：</p>
<pre><code>8(vbptr) + 8(vbptr) + 8(vfptr) + 4(d_) + 4(c_) + +4(b_) + 4(a_) = 40
</code></pre><p>使用了虚继承，D中只会保留一份a_的拷贝，但需要存储B和C两份虚基类表指针。至于为什么补齐了8个bytes呢，从下面g++给出的内存分布可以看出些端倪：</p>
<p><img src="https://cdn.jsdelivr.net/gh/chongg039/blog-pic-repo@master/uPic/GBTuGB.png#center" alt="GBTuGB"></p>
<p>实际的计算顺序我猜是这样的，未经仔细求证，仅做参考：</p>
<pre><code>8(D::vfptr) + 4(B::b_) + 4(字节填充) + 8(B::vbptr) + 4(C::c_) + 4(字节填充) + 8(C::vbptr) + 4(A::a_) + 4(D::d_) = 48
</code></pre><p>由于我对这部分不是很了解，只能做大概猜测。本人才疏学浅暂时也没有精力去详细查证编译器内部的具体存放顺序，请懂的朋友不吝赐教。这部分就先讨论到这里。</p>
<p>由于虚基类是多个派生类共享的基类，因此由谁来初始化虚基类必须明确。C++标准规定，由最派生类直接初始化虚基类。因此，对间接继承了虚基类的类，也必须能直接访问其虚继承来的祖先类，也即应知道其虚继承来的祖先类的地址偏移值。在菱形继承中，两个派生类B、C，一个最派生类D的构造函数的初始化列表中都可以给出虚基类的初始化；但只由最派生类的构造函数实际执行虚基类的初始化。即首先初始化虚基类，再按照顺序调用非虚基类的构造函数。</p>
<p>虚继承只是解决了菱形继承中派生类多个基类内存拷贝的问题，并没有解决多重继承的二义性问题。</p>
<h3 id="前缀自增和后缀自增的效率">前缀自增和后缀自增的效率</h3>
<p>对于内建数据类型，没有差异。对于自定义数据类型，++i更高，因为++i可以返回引用，而i++必须返回对象的值，导致复制开销。不过实际上，编译器优化应该会把这次不必要的复制优化掉，但是构造的开销还是存在。看看这个重载了自增运算符的类：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Op</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Op() <span style="color:#f92672">:</span> x_(<span style="color:#ae81ff">0</span>)
    {};

    <span style="color:#75715e">// 拷贝构造
</span><span style="color:#75715e"></span>    Op(<span style="color:#66d9ef">const</span> Op <span style="color:#f92672">&amp;</span>rhs)
    {
        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;call Op copy ctor&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
        x_ <span style="color:#f92672">=</span> rhs.x_;
    }

    <span style="color:#75715e">// 拷贝赋值
</span><span style="color:#75715e"></span>    Op <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Op <span style="color:#f92672">&amp;</span>rhs)
    {
        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;call Op copy assignment&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>rhs) {
            x_ <span style="color:#f92672">=</span> rhs.x_;
        }
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
    }

    <span style="color:#75715e">// 移动构造
</span><span style="color:#75715e"></span>    Op(Op <span style="color:#f92672">&amp;&amp;</span>rhs) <span style="color:#66d9ef">noexcept</span>
    {
        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;call Op move ctor&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
        x_ <span style="color:#f92672">=</span> rhs.x_;
        rhs.x_ <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }

    <span style="color:#75715e">// 移动赋值
</span><span style="color:#75715e"></span>    Op <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(Op <span style="color:#f92672">&amp;&amp;</span>rhs) <span style="color:#66d9ef">noexcept</span>
    {
        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;call Op move assignment&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>rhs) {
            x_ <span style="color:#f92672">=</span> rhs.x_;
            rhs.x_ <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        }
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
    }

    <span style="color:#75715e">// 前缀自增
</span><span style="color:#75715e"></span>    Op <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>()
    {
        <span style="color:#f92672">++</span>x_;
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
    }

    <span style="color:#75715e">// 后缀自增，参数类型需要是int
</span><span style="color:#75715e"></span>    Op <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(<span style="color:#66d9ef">int</span>)
    {
        <span style="color:#75715e">// 对新对象的构造将调用ctor而不是assignment
</span><span style="color:#75715e"></span>        Op tmp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
        <span style="color:#75715e">// 调用前缀自增，注意++优先级要比解引用高
</span><span style="color:#75715e"></span>        <span style="color:#f92672">++</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
        <span style="color:#66d9ef">return</span> tmp;
    }

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> x_;
};
</code></pre></div><p>则下面两种情况：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    Op op1; 
    <span style="color:#f92672">++</span>op1;  <span style="color:#75715e">// 什么都不发生 
</span><span style="color:#75715e"></span>    op1<span style="color:#f92672">++</span>;  <span style="color:#75715e">// 调用一次拷贝构造
</span><span style="color:#75715e"></span>    Op op2 <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>op1; <span style="color:#75715e">// 一次拷贝构造
</span><span style="color:#75715e"></span>    Op op3 <span style="color:#f92672">=</span> op1<span style="color:#f92672">++</span>; <span style="color:#75715e">// 一次拷贝构造
</span></code></pre></div><p>之前提到过编译器优化的问题，关掉编译器优化看看什么结果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    Op op1; 
    <span style="color:#f92672">++</span>op1;  <span style="color:#75715e">// 什么都不发生 
</span><span style="color:#75715e"></span>    op1<span style="color:#f92672">++</span>;  <span style="color:#75715e">// 调用一次拷贝构造和一次移动构造
</span><span style="color:#75715e"></span>    Op op2 <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>op1; <span style="color:#75715e">// 一次拷贝构造
</span><span style="color:#75715e"></span>    Op op3 <span style="color:#f92672">=</span> op1<span style="color:#f92672">++</span>; <span style="color:#75715e">// 一次拷贝构造、两次移动构造
</span></code></pre></div><p>至于先增在赋值还是先赋值在增就不说了，主要是注意一点<strong>后缀自增得到的是一个右值，运算符是右结合的</strong>，就会出现以下情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/chongg039/blog-pic-repo@master/uPic/HDt1YM.png#center" alt="HDt1YM"></p>
<p>为什么op3可以，而c却不行呢？Effective C++中提到过这个原因，就是因为我们的后缀自增的返回值不是const。这便和内置类型有了不一致的行为，容易使人迷惑。因此我们需要将后缀自增返回一个const：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 后缀自增，参数类型需要是int，返回值需要是const，与内建类型保持一致
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> Op <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(<span style="color:#66d9ef">int</span>)
{
    <span style="color:#75715e">// 对新对象的构造将调用ctor而不是assignment
</span><span style="color:#75715e"></span>    Op tmp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
    <span style="color:#75715e">// 调用前缀自增，注意++优先级要比解引用高
</span><span style="color:#75715e"></span>    <span style="color:#f92672">++</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
    <span style="color:#66d9ef">return</span> tmp;
}
</code></pre></div><p>再看下结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/chongg039/blog-pic-repo@master/uPic/Cwq4VU.png#center" alt="Cwq4VU"></p>
<p>很显然我们不能再对一个const对象进行自增操作，对op4也是一样的，因为运算符的右结合性。</p>
<h3 id="悬垂指针野指针哑指针">悬垂指针、野指针、哑指针</h3>
<p>哑指针就是普通的指针，只有指向的功能。</p>
<p>野指针是指向不可用内存的指针，这里的不可用不是NULL的意思。指向NULL一般可以称其为空指针。一般来说是由于指针未初始化指向的内存导致的。注意，静态指针会自动初始化。</p>
<p>悬垂指针英文名称叫&quot;dangling pointer&quot;，也称为迷途指针。将野指针算作一种悬垂指针也不算错，不过悬垂指针侧重于原来指向了一块内存区域，由于某些原因被释放后，指针本身并没有被修改（比如常用的就是将其赋值nullptr）。指针仍指向该内存区域，但是该区域已经成为了一块”垃圾内存“，内存已被回收，此时该指针就变成了悬垂指针。</p>
<p>处理悬垂指针的方式有这么几种，一是在free或delete后立即将指针赋nullptr，通过宏定义等方式可以写一个smart_free方法来代替；二是使用智能指针，通过RAII方式自动管理堆内存。</p>
<p>注意，一般不要返回指向栈上的指针或引用（比如函数内部），因为栈上的内存会在函数结束后被释放掉。</p>
<h3 id="智能指针">智能指针</h3>
<p>智能指针一个很大的作用是，被建议用来管理第三方库提供的原始指针，不需要自己再去封装一次。</p>
<p>普通指针可以构造成智能指针，但不能直接赋值。</p>
<p>std::shared_ptr可以使用std::unique_ptr构造，但对一个左值需要使用移动语义，std::unique_ptr本身禁止拷贝。</p>
<p>不能通过一个原始指针构造多个std::shared_ptr，每次通过 raw pointer 来构造shared_ptr时候就会分配一个控制块，这时存在两个控制块，也就是说存在两个引用计数。这显然是错误的，因为当这两个shared_ptr被销毁时，对象将会被delete两次。注意this也是原始指针，这种情况尤其要在构造一个std::shared_ptr数组的时候注意。解决这个问题很简单，只要让std::enable_shared_from_this&lt;&hellip;&gt;作为基类即可，但是不能在构造函数中调用shared_from_this()。</p>
<p>针对循环引用的问题，C++11引入的weak_ptr指针可以使计数区域的生命周期受weak_ptr控制，从而能使weak_ptr获取被管理资源的shared计数，从而判断被管理对象是否已被释放。（可以实时动态地知道指向的对象是否被释放,从而有效解决空悬指针问题）。weak_ptr一般配合shared_ptr使用，不会占用引用计数。它的成员函数expired()就是判断指向的对象是否存活。std::weak_ptr需要从一个std::shared_ptr构造。</p>
<p>这部分内容可以参考这篇<a href="http://senlinzhan.github.io/2015/04/24/%E6%B7%B1%E5%85%A5shared-ptr/">文章</a>。</p>
<p>对于动态数组，需要手动构造删除器，也可以用std::default_delete作为删除器：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">shared_ptr<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> ptr1( <span style="color:#66d9ef">new</span> string[<span style="color:#ae81ff">10</span>], 
                         []( string <span style="color:#f92672">*</span>p ) {
                             <span style="color:#66d9ef">delete</span>[] p;
                         });
shared_ptr<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> ptr2( <span style="color:#66d9ef">new</span> string[<span style="color:#ae81ff">10</span>],
                         std<span style="color:#f92672">::</span>default_delete<span style="color:#f92672">&lt;</span>string[]<span style="color:#f92672">&gt;</span>() );

</code></pre></div><p>但是并不会提供[]运算符，所以没什么意义。这种需求建议使用<code>shared_ptr&lt;vector&gt;</code>或<code>shared_ptr&lt;array&gt;</code>。</p>
<p>对于某些情况下使用计数完毕后不需要删除资源的情况，也可以用这个方式显示指定删除器。</p>
<p>同时，不能用一个原始指针构造多个shared_ptr，否则对象在析构时会被delete两次。注意，<code>this</code>也是raw pointer，很容易会写出这种代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Student( <span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span>name ) <span style="color:#f92672">:</span> name_( name ) { }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addToGroup</span>( vector<span style="color:#f92672">&lt;</span>shared_ptr<span style="color:#f92672">&lt;</span>Student<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">&amp;</span>group ) {
        group.push_back( shared_ptr<span style="color:#f92672">&lt;</span>Student<span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">this</span>) );          <span style="color:#75715e">// ERROR
</span><span style="color:#75715e"></span>    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    string name_;
};
</code></pre></div><p>每次调用addToGroup()时都会创建一个控制块，所以这个对象会对应多个引用计数，最终这个对象就会被delete多次，导致运行出错。解决这个问题很简单，只要让<code>std::enable_shared_from_this&lt;Student&gt;</code>作为Student的基类：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Student</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> std<span style="color:#f92672">::</span>enable_shared_from_this<span style="color:#f92672">&lt;</span>Student<span style="color:#f92672">&gt;</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Student( <span style="color:#66d9ef">const</span> string <span style="color:#f92672">&amp;</span>name ) <span style="color:#f92672">:</span> name_( name ) { }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addToGroup</span>( vector<span style="color:#f92672">&lt;</span>shared_ptr<span style="color:#f92672">&lt;</span>Student<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">&amp;</span>group ) {
        group.push_back( shared_from_this() );              <span style="color:#75715e">// OK
</span><span style="color:#75715e"></span>    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    string name_;
};
</code></pre></div><p>unique_ptr缺少一个类似于make_shared的make_unique方法，不过在c++14中会增加make_unique方法。</p>
<p>std::unique_ptr指定删除器的时候需要确定删除器的类型，所以不能直接像shared_ptr指定删除器，可以这样写：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&gt;</span> ptr(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">1</span>), [](<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>p){<span style="color:#66d9ef">delete</span> p;});
</code></pre></div><p>上面这种写法在lambda没有捕获变量的情况下是正确的，如果捕获了变量则会编译报错：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">void</span>(<span style="color:#f92672">*</span>)(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&gt;</span> ptr(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">1</span>), [<span style="color:#f92672">&amp;</span>](<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>p){<span style="color:#66d9ef">delete</span> p;}); <span style="color:#75715e">//错误，因为捕获了变量
</span></code></pre></div><p>为什么lambda捕获了变量作为unique_ptr就会报错呢，因为lambda在没有捕获变量的情况下是可以直接转换为函数指针的，捕获了就不能转换为函数指针。如果希望unique_ptr的删除器支持lambda，可以这样写：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, std<span style="color:#f92672">::</span>function<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&gt;&gt;</span> ptr(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">1</span>), [<span style="color:#f92672">&amp;</span>](<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>p){<span style="color:#66d9ef">delete</span> p;});
</code></pre></div><h3 id="子类以私有继承的方式继承父类">子类以私有继承的方式继承父类</h3>
<p>一个典型的例子就是noncopyable可以以私有继承的方式继承，有以下原因：</p>
<pre><code>若父类没有virtual析构，那么就不应将其派生类视为一个“is-a”的public继承，反而应该视为private的实现继承。
</code></pre><p>但是可能存在的问题就是对一个private继承：</p>
<ol>
<li>父类的私有的成员变量和函数子类无法访问;</li>
<li>父类的公有的以及保护的成员变量都变成了子类的私有成员变量和函数。</li>
</ol>
<p>那理论上派生类是不能再去调用父类的构造函数了，也就是派生类不能构造。但实际上却是可以的，Effective C++中提到：</p>
<pre><code>在子类对象(derived class)对象的base class构造期间,该子类对象的类型是父类(base calss),而不是子类(derived class).在子类对象析构的时候这一条也成立.
</code></pre><p>因此绝不在构造和析构过程中调用virtual函数。建议阅读<a href="https://www.zybuluo.com/lishuhuakai/note/556513">链接</a>。</p>
<h3 id="默认行为">默认行为</h3>
<ol>
<li>class默认继承是private，struct默认继承是public；</li>
<li>class默认访问修饰符private，struct默认访问修饰符public。</li>
</ol>
<h3 id="类成员变量是引用">类成员变量是引用</h3>
<p>类成员变量可以是引用，但要注意几点：</p>
<ol>
<li>不能直接在构造函数中初始化，必须在初始化列表中</li>
<li>形参也必须是引用</li>
<li>因此含有引用型成员变量的类，不能有默认的构造函数</li>
</ol>
<p>MutexLockGuard中就保存了一个MutexLock的引用。</p>
<h3 id="全局变量和静态变量">全局变量和静态变量</h3>
<p>全局变量：在一个代码文件（具体说应该一个 translation unit/compilation unit)）当中，一个变量要么定义在函数中，要么定义在在函数外面。当定义在函数外面时，这个变量就有了全局作用域，成为了全局变量。全局变量不光意味着这个变量可以在整个文件中使用，也意味着这个变量可以在其他文件中使用（这种叫做 external linkage）。</p>
<p>静态变量： 指使用 static 关键字修饰的变量，static 关键字对变量的作用域进行了限制，具体的限制如下：</p>
<ol>
<li>在函数外定义：全局变量，但是只在当前文件中可见（叫做 internal linkage）</li>
<li>在函数内定义：全局变量，但是只在此函数内可见（同时，在多次函数调用中，变量的值不会丢失）</li>
<li>（C++）在类中定义：全局变量，但是只在此类中可见</li>
</ol>
<p>注意静态变量不是不能修改的，能不能被修改只与 const 有关。</p>
<p>extern： extern 是 C 语言中另一个关键字，用来指示变量或函数的定义在别的文件中，使用 extern 可以在多个源文件中共享某个变量。extern 跟 static 在含义上是“水火不容”的，一个表示不能在别的地方用，一个表示要去别的地方找。如果同时使用的话，一定要先使用 static，后使用 extern ，否则结果是未定义的。</p>
<h3 id="newmalloc区别">new、malloc区别</h3>
<ol>
<li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li>
<li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li>
<li>malloc失败返回空指针，new失败抛出异常</li>
</ol>
<h3 id="定义只能在堆栈上创建的对象">定义只能在堆/栈上创建的对象</h3>
<p>只能在堆上：将析构函数设置为私有，注意，此时建议在设置一个公有的destory方法并调用delete this，不然堆上的内存没法释放。</p>
<p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p>
<p>只能在栈上：将 new 和 delete 重载为私有</p>
<p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>
<h3 id="auto_ptr-与-unique_ptr-比较">auto_ptr 与 unique_ptr 比较</h3>
<p>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义；
auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）；</p>
<h3 id="类型安全">类型安全</h3>
<p>C++不是类型安全的，可以发生两个指针之间的强制转换；C#是类型安全的。</p>
<h3 id="在const成员函数中赋值">在const成员函数中赋值</h3>
<p>去掉const，两种方式</p>
<ol>
<li>mutable，无视const</li>
<li>const_cast转换，强制去掉，也能去掉volatile</li>
</ol>
<h3 id="两种隐式转换方式">两种隐式转换方式</h3>
<ol>
<li>单参构造函数，或除了第一个其他都是默认参数的构造函数；</li>
<li>重载()运算符，()前面加上你想要隐式转换的类型</li>
</ol>
<h3 id="构造函数调用虚函数">构造函数调用虚函数</h3>
<p>不能，语法上通过，语义上有问题。
derived class对象内的base class成分会在derived class自身构造之前构造完毕。因此，在base class的构造函数中执行的virtual函数将会是base class的版本，决不会是derived class的版本。
即使目前确实正在构造derived class。</p>
<h3 id="浅拷贝导致的悬垂指针">浅拷贝导致的悬垂指针</h3>
<p>一般来讲浅拷贝是够用的，也就是编译器默认的拷贝行为。但类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。如果此时B中执行析构函数释放掉指向那一块堆的指针，这时A内的指针就将成为悬挂指针。</p>
<h3 id="virtual函数声明为内联">virtual函数声明为内联</h3>
<p>inline是编译期决定，他意味着在执行前就将调用动作替换为被调用函数的本体；virtual是运行期决定，他意味着直道运行期才决定调用哪个函数。二者是冲突的。</p>
<p>但是，当编译阶段就已经知道调用虚函数的指针为多态指针，就是可以的。比如不是通过基类而是派生类的指针访问函数。</p>
<h3 id="实现一个不能被继承的类">实现一个不能被继承的类</h3>
<p>用final修饰</p>
<h3 id="类a包含类b除了include之外的方法">类A包含类B，除了#include之外的方法</h3>
<p>前置声明，然后使用它的引用或者指针。友元和typedef也可以使用。</p>
<p>优点：</p>
<ol>
<li>减小了类A的大小；</li>
<li>只需要重新编译B而不需要重新编译A，提高了编译速度，减少了编译时依赖；</li>
<li>降低了耦合</li>
</ol>
<p>使用前置声明只允许的声明是指针或引用的一个原因是只要这个声明没有执行需要了解类A的大小或者成员的操作就可以了，所以声明成指针或引用是没有执行需要了解类A的大小或者成员的操作的。</p>
<p>当我们需要知道这个类型的大小或者需要知道它的函数签名的时候，我们就需要获得它的定义。</p>
<p>缺点：</p>
<ol>
<li>编译期不能发现错误，可能在运行期出错。</li>
</ol>
<p>模板编程中常用前置声明，项目中不建议使用。</p>
<h3 id="gdb调试命令">gdb调试命令</h3>
<ol>
<li>list 显示源码</li>
<li>run 运行程序</li>
<li>continue 中断后继续运行到下一个断点</li>
<li>step 单步进入</li>
<li>next 单步执行</li>
<li>call 调用某个函数</li>
<li>(backtrace)bt 查看栈</li>
<li>bt N 显示开头N个栈桢</li>
<li>bt -N 显示最后N个栈桢</li>
<li>(frame)f N 显示第N层栈桢</li>
<li>set directory 设置gdb的工作目录</li>
<li>pwd 当前的工作目录</li>
<li>break 函数名 设置断在某个函数</li>
<li>break 文件名:行号 设置断在某一行</li>
<li>info break 查看设置的断点信息</li>
<li>break if condition 条件断点</li>
<li>break 函数名 thread 线程号 设置断点只断某个线程，通过info threads 查看线程号</li>
<li>delete 断点号 断点号… 删除一个或多个断点</li>
<li>disable 断点号 断点号… 禁止一个或多个断点</li>
<li>enable 断点号 断点号… 打开一个或多个断点</li>
<li>command 断点号 断点触发时，执行命令，一般用于打印变量</li>
<li>print {type} xx （以某种格式）打印变量</li>
</ol>
<h3 id="网络编程">网络编程</h3>
<p>同步和异步的概念描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</p>
<p>阻塞和非阻塞的概念描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。</p>
<h3 id="stl">STL</h3>
<p>对std::vector任何操作，一旦引起空间重新配置，指向原有vector的迭代器就都失效了。因为动态增加大小并不是在原空间后面接续新空间，而是以原大小两倍另外配置一块，再将原内容拷贝过来，并释放原空间。如果一边遍历一边插入可能就会产生这个问题，但是一边遍历一边删除则不会，只是需要将erase返回的迭代器作为原迭代器的下一步前进。即earase只会造成指向被删除元素的那个迭代器失效。</p>
<p>对于std::list不存在这个问题，因为存储空间不需要是连续空间，所以插入和接合操作都不会造成原有迭代器的失效，每次插入或者删除一个元素，就配置或是放一个元素空间，非常精准。</p>
<h3 id="加减指针">加减指针</h3>
<p>两个指针相减，若都指向同一个数组，则可以表示这个区间中元素的个数，代表的是距离。但两个指针相加是没有意义的，也是被禁止的。指针中存放的是偏移量，况且两个地址相加减得到的也不是相对首地址的偏移。更不必说<code>int *</code>和<code>char *</code>这样大小不同的指针作加减了。</p>
<p>一般来说，我们希望在一个指针上加一个指针，好似是让该指针前进一样，但是这是一种思维误区，前进或后退指针需要的是加减一个整数。看下面的解释。</p>
<p>Pointer addition is forbidden in C++, you can only subtract two pointers.</p>
<p>The reason for this is that subtracting two pointers gives a logically explainable result - the offset in memory between two pointers. Similarly, you can subtract or add an integral number to/from a pointer, which means &ldquo;move the pointer up or down&rdquo;. Adding a pointer to a pointer is something which is hard to explain. What would the resulting pointner represent?</p>
<p>If by any chance you explicitly need a pointer to a place in memory whose address is the sum of some other two addresses, you can cast the two pointers to int, add ints, and cast back to a pointer. Remember though, that this solution needs huge care about the pointer arithmetic and is something you really should never do.</p>
<h3 id="子类调用父类的同名函数">子类调用父类的同名函数：</h3>
<ol>
<li>子类和父类返回值参数相同，函数名相同，有virtual关键字，则由对象的类型决定调用哪个函数。</li>
<li>子类和父类只要函数名相同，没有virtual关键字，则子类的对象没有办法调用到父类的同名函数,父类的同名函数被隐藏了，也可以强制调用父类的同名函数class::funtion_name或者如果在子类的定义中，使用using即可将子类的同名函数暴露，然后可直接调用。</li>
<li>子类和父类参数不同，函数名相同，有virtual关键字，则不存在多态性，子类的对象没有办法调用到父类的同名函数,父类的同名函数被隐藏了，也可以强制调用父类的同名函数class::funtion_name。</li>
<li>子类和父类返回值不同，参数相同，函数名相同，有virtual关键字，则编译出错error C2555编译器不允许函数名参数相同返回值不同的函数重载。</li>
</ol>
<h3 id="inline-内联函数">inline 内联函数</h3>
<ol>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等<strong>复杂</strong>操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。虚函数不是不能内联，而是表现多态性的时候不能，因为内联是编译期，多态是运行期。</li>
<li>inline指令就象register，它只是对编译器的一种提示，而不是命令。也就是说，只要编译器愿意，它就可以随意地忽略掉你的指令，事实上编译器常常会这么做。</li>
</ol>
<h4 id="优点">优点</h4>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
<h4 id="缺点">缺点</h4>
<ol>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ol>
<h3 id="空类默认的6个函数">空类默认的6个函数</h3>
<p>默认构造、默认析构、拷贝构造、拷贝赋值运算符、取地址运算符、取地址运算符的const版本。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Empty</span>
{};
<span style="color:#75715e">// 等价于
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Empty</span>
{
  <span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Empty();                            <span style="color:#75715e">//缺省构造函数
</span><span style="color:#75715e"></span>    Empty(<span style="color:#66d9ef">const</span> Empty <span style="color:#f92672">&amp;</span>rhs);            <span style="color:#75715e">//拷贝构造函数
</span><span style="color:#75715e"></span>    <span style="color:#f92672">~</span>Empty();                           <span style="color:#75715e">//析构函数 
</span><span style="color:#75715e"></span>    Empty<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Empty <span style="color:#f92672">&amp;</span>rhs); <span style="color:#75715e">//赋值运算符
</span><span style="color:#75715e"></span>    Empty<span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&amp;</span>();                 <span style="color:#75715e">//取址运算符
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> Empty<span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&amp;</span>() <span style="color:#66d9ef">const</span>;     <span style="color:#75715e">//取址运算符(const版本)
</span><span style="color:#75715e"></span>};
</code></pre></div><h3 id="this指针存放">this指针存放</h3>
<p>计算对象大小的时候不带有this指针，那他存放在哪里？</p>
<p>**当一个对象调用某成员函数时会隐式传入一个参数， 这个参数就是this指针。this指针中存放的就是这个对象的首地址。**这和C中通过向函数传递结构体变量的地址是不是很像？！只是传参形式不一样罢了！ 在C中我们是手工把结构体变量和函数关联起来的，而C++则是编译器帮我们把类数据和成员函数关联起来的并通过名称粉碎和编译时检查等形式防止外部的任意访问。</p>
<p>那么这个this指针存放在哪里呢？其实编译器在生成程序时加入了获取对象首地址的相关代码。并把获取的首地址存放在了寄存器ECX中(VC++编译器是放在ECX中，其它编译器有可能不同)。</p>
<p>也就是成员函数的其它参数正常都是存放在栈中。而this指针参数则是存放在寄存器中。<strong>类的静态成员函数因为没有this指针这个参数，所以类的静态成员函数也就无法调用类的非静态成员变量。</strong></p>
<h3 id="不要在析构函数中抛出异常">不要在析构函数中抛出异常</h3>
<p>若在delete前，会引起内存泄露，引发更多异常。</p>
<h3 id="五个内存存储区">五个内存存储区</h3>
<ol>
<li>全局/静态存储区域：存全局变量，静态变量。程序编译时内存已分配好，并存在于程序整个运行期间，程序结束后由系统统一释放。全局变量和静态变量被分配到同一块内存中。C 语言中，全局变量又分为初始化的和未初始化的。初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域。同时未被初始化的对象存储区可以通过 void* 来访问和操纵，程序结束后由系统自行释放。在 C++ 里面没有区分，他们共同占用同一块内存区。</li>
<li>栈：存放函数的参数值，局部变量，函数执行结束时会被自动释放。栈内存分配运算内置于处理器的指令集中，效率高，但是容量有限。</li>
<li>堆（动态内存分配）：通过new和malloc由低到高分配，由delete或free手动释放或者程序结束自动释放。动态内存的生存期人为决定，使用灵活。缺点是容易分配/释放不当容易造成内存泄漏，频繁分配/释放会产生大量内存碎片。 若程序员不释放，程序结束时可能由OS（操作系统）回收</li>
<li>字符/文字常量区： 存放常量字符串，程序结束时由系统释放</li>
<li>程序代码区： 存放函数体的二进制代码</li>
</ol>
<p>其中，虚函数表存放在全局存储区域。</p>
<h3 id="new使用free释放">new使用free释放</h3>
<ol>
<li>new未必是使用malloc分配的内存，可能是内存池中自由链表维护的那块内存；</li>
<li>delete会调用析构函数，free不会；</li>
<li>没有free[]</li>
<li>new和delete是运算符，类可以定义自己的delete。</li>
</ol>
<h3 id="使用lambda函数提高运行效率">使用lambda函数提高运行效率</h3>
<p>在使用到c++ stl中算法的时候，很多情况下需要传入函数对象或函数指针，根据effective stl书中的描述，传递函数对象运行效率要比函数指针高。原因是算法函数中可以根据函数对象内联展开调用的函数，而当传入函数指针时，这种内联展开的技术不可能实现，因此存在大量函数调用的情况。</p>
<p>当使用lambda函数时，编译器到底是怎么处理的，1、像是函数对象那样，可以内联展开，还是2、像函数指针那样，一定要进行函数调用实现呢？</p>
<p>使用lambda函数的效率与使用函数对象是一样的，都要快于函数指针。他们都能够在编译期将代码内联展开，减少函数调用的时间</p>

    
    
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: '36c8fa6e09d08297a270',
    clientSecret: 'af0175944284956d288d14b389fbc89be8df7f1e',
    repo: 'chongg039.github.io',
    owner: 'chongg039',
    admin: ['chongg039'],
    id: location.pathname, 
    distractionFreeMode: false 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>

<div class="navfooter">
    <table width="100%" summary="Navigation footer">
        <tbody>
            <tr>
                <td width="40%" align="left">&nbsp;</td>
                <td width="20%" align="center">&nbsp;</td>
                <td width="40%" align="right">&nbsp;</td>
            </tr>
            <tr>
                <td width="40%" align="left" valign="top">
                    <span class="copyright">
                        Copyright 2014-2021
                    </span>
                    &nbsp;
                </td>
                <td width="20%" align="center">&nbsp;</td>
                <td width="40%" align="right" valign="top">&nbsp;<a href="https://chongg039.cn/">HOME</a></td>
            </tr>
        </tbody>
    </table>
</div>
</body>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: { 
            inlineMath: [ ['$','$'], ['\\(','\\)'] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true
        }
    });
    </script>
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-117991024-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    <script type="text/javascript" src="https://chongg039.cn/js/function.js"></script>
    <script type="text/javascript" src="https://chongg039.cn/js/prettify.js"></script>
    
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
</html>

