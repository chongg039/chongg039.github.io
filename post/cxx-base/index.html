<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>[基础知识]C&#43;&#43;基础知识汇总</title>
    <link rel="stylesheet" type="text/css" href="https://chongg039.cn/css/style.css" />
    
    <link rel="shortcut icon" href="https://chongg039.cn/img/favicon.ico">
    <link rel="stylesheet" type="text/css" href="https://chongg039.cn/css/sunburst.css" />
</head>
<body onload="PR.prettyPrint()">
    <div class="navheader">
        <table width="100%" summary="Navigation header">
            <tbody>
                <tr>
                    <td colspan="3" align="center">Co1driver 的个人博客</td>
                </tr>
                <tr>
                    <td width="90%" align="left">&nbsp;</td>
                    <td width="5%" align="center">&nbsp;<a accesskey="h" href="https://github.com/chongg039">GITHUB</a></td>
                    <td width="5%" align="right">&nbsp;<a accesskey="a" href="https://chongg039.cn//about">ABOUT</a></td>
                </tr>
            </tbody>
        </table>
    </div>

    <h1>[基础知识]C&#43;&#43;基础知识汇总</h1>
    <h4>Sun, Oct 20, 2019</h4>
    <h3 id="指针和引用">指针和引用</h3>
<h4 id="联系">联系</h4>
<p>C++底层中引用是通过指针实现的，在实现层面上引用就是指针，指向同一对象的内存地址。</p>
<p>所有对引用的操作就是对原始对象的操作。</p>
<h4 id="区别">区别</h4>
<ol>
<li>引用只是别名，不是实体类型，因此编译器不为引用分配单独的内存空间，而指针有自己的内存空间，因此某种程度上指针不能被引用取代；</li>
<li>引用必须被初始化且不能为空，但可以有未初始化的空指针；</li>
<li>引用一旦初始化就不能更换目标，即不能被初始化多次，指针可以更改指向的对象；</li>
<li>可以有指针数组，不能有引用数组，因为引用没有被分配内存；</li>
<li>当引用作为函数的形参时，因为函数形参和实参是同一个对象，避免了复制对象的开销；</li>
<li>若对引用型参数做const修饰，则不会调用拷贝构造函数，提高效率；</li>
<li>若引用作为函数的返回结果，需要保证函数返回后被引用的目标一直有效，即不能返回函数内部的局部对象的引用（因为离开作用域后会被析构掉）。</li>
</ol>
<h3 id="数组和指针">数组和指针</h3>
<p>C++不记录数组本身的大小，因此一定注意不要越界访问。</p>
<p>数组作为形参传递时会退化为同类型的指针：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> data[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>};
<span style="color:#66d9ef">int</span> size1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(data); <span style="color:#75715e">// 20
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>data2 <span style="color:#f92672">=</span> data;
<span style="color:#66d9ef">int</span> size2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(data2); <span style="color:#75715e">// 4
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">GetSize</span>(<span style="color:#66d9ef">int</span> data[])
{
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">sizeof</span>(data);
}
<span style="color:#66d9ef">int</span> size3 <span style="color:#f92672">=</span> GetSize(data); <span style="color:#75715e">// 4
</span></code></pre></div><h3 id="sizeof使用与陷阱">sizeof使用与陷阱</h3>
<p><a href="https://www.cnblogs.com/chio/archive/2007/06/11/778934.html">https://www.cnblogs.com/chio/archive/2007/06/11/778934.html</a></p>
<h3 id="内存对齐">内存对齐</h3>
<p>尽管计算机中内存是按照字节byte划分的，但不是寻址可以从任意的byte开始。一般来说计算机会对基本数据类型数据在内存中存放的位置加以限制，要求首地址必须是某个数（一般是4和8）的倍数，这就是内存对齐。</p>
<p>因为虽然计算机按照字节划分存储空间，但处理器存取一次内存不是按照一个字节存取的，一般以双字节、4字节、8字节甚至到32字节存取。这被称为内存存取粒度。</p>
<p>对32位处理器的int类型（4字节），若数据现在可以存放在任一字节开始处，会产生性能的损失。比如，现在从地址1字节开始存放int（1-5，左开右闭），读取时从0字节开始读取一个4字节大小的块，需要访问两次内存。第一步先读取0-4左开右闭字节快，剔除0地址字节；第二步访问4-8左开右闭字节快，剔除5、6、7三个字节块。然后将这两部分得到的合并放入寄存器，需要做很多工作。有了内存对齐，那么只能从规定的边界存放和读取，访问一次内存就可以了。</p>
<p>设置编译器的”对齐系数(对齐模数)“的预处理指令为#pragma pack(n)，一般32位系统下对齐系数为n=4，64位系统下对齐系数为n=8。还有一个概念为”对齐单位“，也称有效对齐值，是指n和结构体中最长数据类型（基本数据类型）长度中较小的那一个值。</p>
<p>下面说一下内存对齐规则，主要有两条：</p>
<ol>
<li>结构体中第一个成员的offset为0，之后每个成员都相对首地址的offset都是”该成员大小“和”对齐单位“中较小的那个的整数倍。如有需要可以添加进填充字节；</li>
<li>结构体的总大小为”对齐单位“的整数倍，如有需要会在最末尾成员添加填充字节。</li>
</ol>
<p>分析下下面三个例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#pragma pack(4)
</span><span style="color:#75715e"></span><span style="color:#75715e">// 先使用第一条规则
</span><span style="color:#75715e">//  对x, 对齐单位min(4, 4) = 4, 按照4字节对齐, 不用偏移, 从0开始占用4个字节
</span><span style="color:#75715e">//  对c1, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从4开始占用1个字节
</span><span style="color:#75715e">//  对c2, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从5开始占用1个字节
</span><span style="color:#75715e">// 再使用第二条规则, 结构体大小需要是对齐单位的整数倍, 补2个字节在末尾
</span><span style="color:#75715e">// sizeof(x1) = 8
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">x1</span>
{
    <span style="color:#66d9ef">int</span> x;
    <span style="color:#66d9ef">char</span> c1;
    <span style="color:#66d9ef">char</span> c2;
} x1;

<span style="color:#75715e">// 先使用第一条规则
</span><span style="color:#75715e">//  对c1, 对齐单位min(4, 1) = 1, 按照1字节对齐, 不用偏移, 从0开始占用1个字节
</span><span style="color:#75715e">//  对c2, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从1开始占用1个字节
</span><span style="color:#75715e">//  对x, 对齐单位min(4, 4) = 4, 按照4字节对齐, 相对于首地址偏移min(4, 4) = 4的倍数, 需要先填充2位, 再从4开始占用4个字节
</span><span style="color:#75715e">// 再使用第二条规则, 结构体大小需要是对齐单位的整数倍, 不用补填充字节
</span><span style="color:#75715e">// sizeof(x2) = 8
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">x2</span>
{
    <span style="color:#66d9ef">char</span> c1;
    <span style="color:#66d9ef">char</span> c2;
    <span style="color:#66d9ef">int</span> x;
} x2;

<span style="color:#75715e">// 先使用第一条规则
</span><span style="color:#75715e">//  对c1, 对齐单位min(4, 1) = 1, 按照1字节对齐, 不用偏移, 从0开始占用1个字节
</span><span style="color:#75715e">//  对x, 对齐单位min(4, 4) = 4, 按照4字节对齐, 相对于首地址偏移min(4, 4) = 1的倍数, 需要先填充3位, 再从4开始占用4个字节
</span><span style="color:#75715e">//  对c2, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从8开始占用1个字节
</span><span style="color:#75715e">// 再使用第二条规则, 结构体大小需要是对齐单位的整数倍, 补3个字节在末尾
</span><span style="color:#75715e">// sizeof(x3) = 12
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">x3</span>
{
    <span style="color:#66d9ef">char</span> c1;
    <span style="color:#66d9ef">int</span> x;
    <span style="color:#66d9ef">char</span> c2;
} x3;
<span style="color:#75715e">#pragma pack()
</span></code></pre></div><p>准确地讲这是属于内存的字节对齐。还有一个问题是大端对齐和小端对齐，这和处理器的架构有关系。大端对齐模式就是数据的低位保存在内存的高地址，内存的低地址存放着数据的高位。小端对齐模式就是数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。一般都是使用小端对齐的方式，大端对齐主要用在一些大型机的处理器中。</p>
<h3 id="多态">多态</h3>
<p>重载overload，重写override，重定义overwrite</p>
<pre><code>重载：函数名相同，函数的参数个数、参数类型或参数顺序三者中必须至少有一种不同。函数返回值的类型可以相同，也可以不相同。发生在一个类内部。

重写：也叫做覆盖，一般发生在子类和父类继承关系之间。子类重新定义父类中有相同名称和参数的虚函数。(override)

重定义：也叫做隐藏，子类重新定义父类中有相同名称的非虚函数(参数列表可以不同)，指派生类的函数屏蔽了与其同名的基类函数。可以理解成发生在继承中的重载。
</code></pre><p>多态主要指静态多态和动态多态。静态多态就是函数重载，也包含函数模板和类模板的参数多态性，在编译期完成；动态多态是在程序运行时根据基类的指针或引用指向的对象来确定自己具体该调用哪一个类的虚函数，在运行期确定。</p>
<p>构造函数不能被virtual修饰，基类的析构函数有必要声明为virtual，否则子类析构不能被正确调用。**将基类的析构函数声明为虚函数后，派生类的析构函数也会自动成为虚函数。**static成员函数不能声明为虚函数，因为它属于类而不属于某个对象。在C++11中，被final修饰的虚函数不能被子类重写。</p>
<p>构造函数不能是虚函数。而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被disable的。 析构函数可以是纯虚的，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。</p>
<p>virtual + &quot; = 0&quot;形式上告诉了编译器这是一个纯虚函数，包含纯虚函数的类不能被实例化。对于纯虚析构函数，正常情况下子类是不能被实例化的，因为子类在析构时会调用基类的析构函数，而基类的析构函数纯虚，没有一个默认的实现，此时会报出链接错误。但事实上，一个纯虚析构函数我们仍可为其指定一个实现，这样子类的在析构时只会调用自己的析构函数。虽然看起来有些奇怪，但编译器并不会对此抱怨什么，不过很显然这里的实现就不能写成inline的了。<strong>上面说明了：可以有纯虚析构函数，但是必须有定义体。</strong></p>
<p>为什么编译器可以在运行时通过指针指向的对象找到虚函数？如果一个类包含虚函数，编译器在编译阶段会额外增加一个数组，数组中的每个元素都是虚函数的入口地址。这个数组就是虚函数表vtable。虚函数表是属于类的，不属于任何一个对象。在代码的编译阶段这个虚函数表就可以构造出来。</p>
<p>为了将实例化的对象和虚函数表关联起来，编译器在带有虚函数的对象中插入了一个指针vfptr，指向对应类的虚函数表的起始位置，这就是相似的带有虚函数的对象要比不带虚函数的对象要大的原因。同一个类的所有对象使用同一份虚函数表。注意，若一个类的基类包含虚函数，那这个类也拥有自己的虚表，类的对象拥有一个指向这个虚表的虚表指针。</p>
<p>vfptr的分步初始化：在构造子类对象时，执行父类构造函数时，子类的vfptr指针指向父类的虚函数表，当父类构造函数执行完毕后，子类的vfptr会指向子类的虚函数表。</p>
<p>关于动态绑定可以看这个<a href="https://blog.csdn.net/lihao21/article/details/50688337">博客</a>。</p>
<p>对于单继承的情况：</p>
<ol>
<li>基类的虚函数在vtable中的索引（下标）是固定的，不会随着继承层次的增加而改变，派生类新增的虚函数放在vtable的最后；</li>
<li>如果派生类有同名的虚函数override了基类的虚函数，那么将使用派生类的虚函数替换基类的虚函数，这样具有override关系的虚函数在vtable中只会出现一次；</li>
<li>当通过指针调用虚函数时，先根据指针找到vfptr，再根据vfptr找到虚函数的入口地址；对于不同的虚函数，仅仅改变索引（下标）即可。</li>
</ol>
<h4 id="插一句对象大小的计算">插一句对象大小的计算</h4>
<ol>
<li>非虚成员函数、静态成员函数、静态成员变量、静态常量成员变量均不影响对象的内存大小；</li>
<li>虚函数影响对象大小，因为虚函数表指针；</li>
<li>虚继承影响对象大小，因为虚基表指针；</li>
<li>空类对象大小为1，空类是指既没有非静态数据成员，也没有虚函数，也不存在虚继承；</li>
<li>继承一个空类有两种情况：一是派生类也是空类，派生类大小也为1；二是派生类不是空类，注意此时基类的一个字节大小并不会算进派生类的内存空间当中；</li>
<li>包含一个空类，此时派生类的内存空间将包含这一个字节的大小（最终计算不要忘记考虑字节对齐）。</li>
</ol>
<h4 id="普通多继承菱形继承和虚继承">普通多继承、菱形继承和虚继承</h4>
<p>有两个分属与不同集成体系的基类B1和B2，派生类同时继承这两个基类，这就是普通的多继承。由于多个基类分属不同的继承体系，一般不会出现什么问题，尽管不提倡使用多继承。</p>
<p>菱形继承怎么产生的呢，看一张来自Wikipedia图片：</p>
<p><img src="https://cdn.jsdelivr.net/gh/chongg039/blog-pic-repo@master/uPic/yr9Dxf.jpg#center" alt="yr9Dxf"></p>
<p>这会带来以下两个问题：</p>
<ol>
<li>若A中有非静态成员变量x，那么在D中最终将有两个x，不仅增大了内存，使用x也会产生二义性问题；</li>
<li>若A中有一个成员函数，D调用该成员函数会产生二义性。若B和C中定义了同名（参数表可以不同）的两个成员函数，调用某一个也会产生二义性；</li>
</ol>
<p>先看普通的菱形继承的内存占用大小，在我的64位系统上对齐系数是8bytes：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    A() <span style="color:#f92672">:</span> a_(<span style="color:#ae81ff">0</span>)
    {};

    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>A() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> a_;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    B() <span style="color:#f92672">:</span> b_(<span style="color:#ae81ff">1</span>)
    {};
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> b_;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    C() <span style="color:#f92672">:</span> c_(<span style="color:#ae81ff">1</span>)
    {};
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> c_;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> B, <span style="color:#66d9ef">public</span> C
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    D() <span style="color:#f92672">:</span> d_(<span style="color:#ae81ff">2</span>)
    {};
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> d_;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(A) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 16
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(B) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 16
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(C) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 16
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(D) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 36/40
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>64位系统上int占4bytes，一个虚函数表指针占8bytes，最终A占用大小为12，算上8bytes对齐就是16；对于B，成员b_和a_各占4bytes，很幸运的不需要填充字节，然后因为里面有个继承来的虚函数，虚表指针占用8bytes，最终大小是16（如果不相信，可以将对齐系数改为4做个对比验证）；C和B的情况一样；对于D，情况有些特殊，计算方式为：</p>
<pre><code>4(d_) + 4(c_) + 4(b_) + 4(a_) + 4(a_) + 8(vfptr) + 8(vfptr) + 4(尾字节对齐)= 40
</code></pre><p>很显然，前面说过D中会有A中数据成员的两分拷贝。又因为D继承B、C两个分支，所以会有两个虚函数表指针。在这里说明一下，**带有虚函数的类，其大小和虚函数的个数无关，只与虚函数表指针的个数有关。**对于A，写再多的虚函数，虚函数表指针也只有一个。</p>
<p>一个解决方案是使用using限定作用域来达到消歧的目的，但永远不会是最优。菱形继承问题引出了使用虚继承的解决方案：如果类B与C各自虚继承了类A，那么D的对象就只包含一套类A的实例数据。这一特性在多重继承应用中非常有用，可以使得虚基类对于由它直接或间接派生的类来说，拥有一个共同的基类对象实例。间接派生类D穿透了其父类B、C，实质上直接继承了虚基类A。</p>
<p>再看看使用了虚继承后内存占用的大小，还是8bytes对齐：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    A() <span style="color:#f92672">:</span> a_(<span style="color:#ae81ff">0</span>)
    {};

    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>A() <span style="color:#f92672">=</span> <span style="color:#66d9ef">default</span>;

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> a_;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span> A
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    B() <span style="color:#f92672">:</span> b_(<span style="color:#ae81ff">1</span>)
    {};
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> b_;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">public</span> A
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    C() <span style="color:#f92672">:</span> c_(<span style="color:#ae81ff">1</span>)
    {};
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> c_;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> B, <span style="color:#66d9ef">public</span> C
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    D() <span style="color:#f92672">:</span> d_(<span style="color:#ae81ff">2</span>)
    {};
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> d_;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(A) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 16
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(B) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 32
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(C) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 32
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">sizeof</span>(D) <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl; <span style="color:#75715e">// 48
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>对A没什么好说的，还是一样；对B，现在的计算方式为：</p>
<pre><code>4(b_) + 4(a_) + 8(vfptr) + 8(vbptr) = 24
</code></pre><p>这个vbptr就是虚基类表指针。至于为什么最终结果是32，我想是由于内存中存放顺序的原因，一般来说会先将两个虚表指针放在低位，再将数据成员放在后面，这样就会由于8bytes对齐导致填充字节后的最终结果是32。若将对齐系数改为4，最终大小就是24了。对于C，情况和B一样。</p>
<p>对于D，现在应该这样计算：</p>
<pre><code>8(vbptr) + 8(vbptr) + 8(vfptr) + 4(d_) + 4(c_) + +4(b_) + 4(a_) = 40
</code></pre><p>使用了虚继承，D中只会保留一份a_的拷贝，但需要存储B和C两份虚基类表指针。至于为什么补齐了8个bytes呢，从下面g++给出的内存分布可以看出些端倪：</p>
<p><img src="https://cdn.jsdelivr.net/gh/chongg039/blog-pic-repo@master/uPic/GBTuGB.png#center" alt="GBTuGB"></p>
<p>实际的计算顺序我猜是这样的，未经仔细求证，仅做参考：</p>
<pre><code>8(D::vfptr) + 4(B::b_) + 4(字节填充) + 8(B::vbptr) + 4(C::c_) + 4(字节填充) + 8(C::vbptr) + 4(A::a_) + 4(D::d_) = 48
</code></pre><p>由于我对这部分不是很了解，只能做大概猜测。本人才疏学浅暂时也没有精力去详细查证编译器内部的具体存放顺序，请懂的朋友不吝赐教。这部分就先讨论到这里。</p>
<p>由于虚基类是多个派生类共享的基类，因此由谁来初始化虚基类必须明确。C++标准规定，由最派生类直接初始化虚基类。因此，对间接继承了虚基类的类，也必须能直接访问其虚继承来的祖先类，也即应知道其虚继承来的祖先类的地址偏移值。在菱形继承中，两个派生类B、C，一个最派生类D的构造函数的初始化列表中都可以给出虚基类的初始化；但只由最派生类的构造函数实际执行虚基类的初始化。即首先初始化虚基类，再按照顺序调用非虚基类的构造函数。</p>
<p>虚继承只是解决了菱形继承中派生类多个基类内存拷贝的问题，并没有解决多重继承的二义性问题。</p>
<h3 id="前缀自增和后缀自增的效">前缀自增和后缀自增的效</h3>
<p>对于内建数据类型，没有差异。对于自定义数据类型，++i更高，因为++i可以返回引用，而i++必须返回对象的值，导致复制开销。不过实际上，编译器优化应该会把这次不必要的复制优化掉，但是构造的开销还是存在。看看这个重载了自增运算符的类：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Op</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Op() <span style="color:#f92672">:</span> x_(<span style="color:#ae81ff">0</span>)
    {};

    <span style="color:#75715e">// 拷贝构造
</span><span style="color:#75715e"></span>    Op(<span style="color:#66d9ef">const</span> Op <span style="color:#f92672">&amp;</span>rhs)
    {
        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;call Op copy ctor&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
        x_ <span style="color:#f92672">=</span> rhs.x_;
    }

    <span style="color:#75715e">// 拷贝赋值
</span><span style="color:#75715e"></span>    Op <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> Op <span style="color:#f92672">&amp;</span>rhs)
    {
        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;call Op copy assignment&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>rhs) {
            x_ <span style="color:#f92672">=</span> rhs.x_;
        }
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
    }

    <span style="color:#75715e">// 移动构造
</span><span style="color:#75715e"></span>    Op(Op <span style="color:#f92672">&amp;&amp;</span>rhs) <span style="color:#66d9ef">noexcept</span>
    {
        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;call Op move ctor&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
        x_ <span style="color:#f92672">=</span> rhs.x_;
        rhs.x_ <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }

    <span style="color:#75715e">// 移动赋值
</span><span style="color:#75715e"></span>    Op <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(Op <span style="color:#f92672">&amp;&amp;</span>rhs) <span style="color:#66d9ef">noexcept</span>
    {
        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;call Op move assignment&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
        <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">this</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>rhs) {
            x_ <span style="color:#f92672">=</span> rhs.x_;
            rhs.x_ <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        }
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
    }

    <span style="color:#75715e">// 前缀自增
</span><span style="color:#75715e"></span>    Op <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>()
    {
        <span style="color:#f92672">++</span>x_;
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
    }

    <span style="color:#75715e">// 后缀自增，参数类型需要是int
</span><span style="color:#75715e"></span>    Op <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(<span style="color:#66d9ef">int</span>)
    {
        <span style="color:#75715e">// 对新对象的构造将调用ctor而不是assignment
</span><span style="color:#75715e"></span>        Op tmp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
        <span style="color:#75715e">// 调用前缀自增，注意++优先级要比解引用高
</span><span style="color:#75715e"></span>        <span style="color:#f92672">++</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
        <span style="color:#66d9ef">return</span> tmp;
    }

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> x_;
};
</code></pre></div><p>则下面两种情况：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    Op op1; 
    <span style="color:#f92672">++</span>op1;  <span style="color:#75715e">// 什么都不发生 
</span><span style="color:#75715e"></span>    op1<span style="color:#f92672">++</span>;  <span style="color:#75715e">// 调用一次拷贝构造
</span><span style="color:#75715e"></span>    Op op2 <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>op1; <span style="color:#75715e">// 一次拷贝构造
</span><span style="color:#75715e"></span>    Op op3 <span style="color:#f92672">=</span> op1<span style="color:#f92672">++</span>; <span style="color:#75715e">// 一次拷贝构造
</span></code></pre></div><p>之前提到过编译器优化的问题，关掉编译器优化看看什么结果：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    Op op1; 
    <span style="color:#f92672">++</span>op1;  <span style="color:#75715e">// 什么都不发生 
</span><span style="color:#75715e"></span>    op1<span style="color:#f92672">++</span>;  <span style="color:#75715e">// 调用一次拷贝构造和一次移动构造
</span><span style="color:#75715e"></span>    Op op2 <span style="color:#f92672">=</span> <span style="color:#f92672">++</span>op1; <span style="color:#75715e">// 一次拷贝构造
</span><span style="color:#75715e"></span>    Op op3 <span style="color:#f92672">=</span> op1<span style="color:#f92672">++</span>; <span style="color:#75715e">// 一次拷贝构造、两次移动构造
</span></code></pre></div><p>至于先增在赋值还是先赋值在增就不说了，主要是注意一点<strong>后缀自增得到的是一个右值，运算符是右结合的</strong>，就会出现以下情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/chongg039/blog-pic-repo@master/uPic/HDt1YM.png#center" alt="HDt1YM"></p>
<p>为什么op3可以，而c却不行呢？Effective C++中提到过这个原因，就是因为我们的后缀自增的返回值不是const。这便和内置类型有了不一致的行为，容易使人迷惑。因此我们需要将后缀自增返回一个const：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 后缀自增，参数类型需要是int，返回值需要是const，与内建类型保持一致
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> Op <span style="color:#66d9ef">operator</span><span style="color:#f92672">++</span>(<span style="color:#66d9ef">int</span>)
{
    <span style="color:#75715e">// 对新对象的构造将调用ctor而不是assignment
</span><span style="color:#75715e"></span>    Op tmp <span style="color:#f92672">=</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>;
    <span style="color:#75715e">// 调用前缀自增，注意++优先级要比解引用高
</span><span style="color:#75715e"></span>    <span style="color:#f92672">++</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>);
    <span style="color:#66d9ef">return</span> tmp;
}
</code></pre></div><p>再看下结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/chongg039/blog-pic-repo@master/uPic/Cwq4VU.png#center" alt="Cwq4VU"></p>
<p>很显然我们不能再对一个const对象进行自增操作，对op4也是一样的，因为运算符的右结合性。</p>
<h3 id="悬垂指针野指针哑指针">悬垂指针、野指针、哑指针</h3>
<p>哑指针就是普通的指针，只有指向的功能。</p>
<p>野指针是指向不可用内存的指针，这里的不可用不是NULL的意思。指向NULL一般可以称其为空指针。一般来说是由于指针未初始化指向的内存导致的。注意，静态指针会自动初始化。</p>
<p>悬垂指针英文名称叫&quot;dangling pointer&rdquo;，也称为迷途指针。将野指针算作一种悬垂指针也不算错，不过悬垂指针侧重于原来指向了一块内存区域，由于某些原因被释放后，指针本身并没有被修改（比如常用的就是将其赋值nullptr）。指针仍指向该内存区域，但是该区域已经成为了一块”垃圾内存“，内存已被回收，此时该指针就变成了悬垂指针。</p>
<p>处理悬垂指针的方式有这么几种，一是在free或delete后立即将指针赋nullptr，通过宏定义等方式可以写一个smart_free方法来代替；二是使用智能指针，通过RAII方式自动管理堆内存。</p>
<p>注意，一般不要返回指向栈上的指针或引用（比如函数内部），因为栈上的内存会在函数结束后被释放掉。</p>
<h3 id="智能指针">智能指针</h3>
<p>普通指针可以构造成智能指针，但不能直接赋值。</p>
<p>std::shared_ptr可以使用std::unique_ptr构造，但对一个左值需要使用移动语义，std::unique_ptr本身禁止拷贝。</p>
<p>不能通过一个原始指针构造多个std::shared_ptr，每次通过 raw pointer 来构造shared_ptr时候就会分配一个控制块，这时存在两个控制块，也就是说存在两个引用计数。这显然是错误的，因为当这两个shared_ptr被销毁时，对象将会被delete两次。注意this也是原始指针，这种情况尤其要在构造一个std::shared_ptr数组的时候注意。解决这个问题很简单，只要让std::enable_shared_from_this&lt;&hellip;&gt;作为基类即可，但是不能在构造函数中调用shared_from_this()。</p>
<p>针对循环引用的问题，C++11引入的weak_ptr指针可以使计数区域的生命周期受weak_ptr控制，从而能使weak_ptr获取被管理资源的shared计数，从而判断被管理对象是否已被释放。（可以实时动态地知道指向的对象是否被释放,从而有效解决空悬指针问题）。weak_ptr一般配合shared_ptr使用，不会占用引用计数。它的成员函数expired()就是判断指向的对象是否存活。std::weak_ptr需要从一个std::shared_ptr构造。</p>
<p>这部分内容可以参考这篇<a href="http://senlinzhan.github.io/2015/04/24/%E6%B7%B1%E5%85%A5shared-ptr/">文章</a>。</p>
<h3 id="子类以私有继承的方式继承父类">子类以私有继承的方式继承父类</h3>
<p>一个典型的例子就是noncopyable可以以私有继承的方式继承，有以下原因：</p>
<pre><code>若父类没有virtual析构，那么就不应将其派生类视为一个“is-a”的public继承，反而应该视为private的实现继承。
</code></pre><p>但是可能存在的问题就是对一个private继承：</p>
<ol>
<li>父类的私有的成员变量和函数子类无法访问;</li>
<li>父类的公有的以及保护的成员变量都变成了子类的私有成员变量和函数。</li>
</ol>
<p>那理论上派生类是不能再去调用父类的构造函数了，也就是派生类不能构造。但实际上却是可以的，Effective C++中提到：</p>
<pre><code>在子类对象(derived class)对象的base class构造期间,该子类对象的类型是父类(base calss),而不是子类(derived class).在子类对象析构的时候这一条也成立.
</code></pre><p>因此绝不在构造和析构过程中调用virtual函数。建议阅读<a href="https://www.zybuluo.com/lishuhuakai/note/556513">链接</a>。</p>
<h3 id="默认行为">默认行为</h3>
<ol>
<li>class默认继承是private，struct默认继承是public；</li>
<li>class默认访问修饰符private，struct默认访问修饰符public。</li>
</ol>
<h3 id="类成员变量是引用">类成员变量是引用</h3>
<p>类成员变量可以是引用，但要注意几点：</p>
<ol>
<li>不能直接在构造函数中初始化，必须在初始化列表中</li>
<li>形参也必须是引用</li>
<li>因此含有引用型成员变量的类，不能有默认的构造函数</li>
</ol>
<p>MutexLockGuard中就保存了一个MutexLock的引用。</p>
<h3 id="全局变量和静态变量">全局变量和静态变量</h3>
<p>全局变量：在一个代码文件（具体说应该一个 translation unit/compilation unit)）当中，一个变量要么定义在函数中，要么定义在在函数外面。当定义在函数外面时，这个变量就有了全局作用域，成为了全局变量。全局变量不光意味着这个变量可以在整个文件中使用，也意味着这个变量可以在其他文件中使用（这种叫做 external linkage）。</p>
<p>静态变量： 指使用 static 关键字修饰的变量，static 关键字对变量的作用域进行了限制，具体的限制如下：</p>
<ol>
<li>在函数外定义：全局变量，但是只在当前文件中可见（叫做 internal linkage）</li>
<li>在函数内定义：全局变量，但是只在此函数内可见（同时，在多次函数调用中，变量的值不会丢失）</li>
<li>（C++）在类中定义：全局变量，但是只在此类中可见</li>
</ol>
<p>注意静态变量不是不能修改的，能不能被修改只与 const 有关。</p>
<p>extern： extern 是 C 语言中另一个关键字，用来指示变量或函数的定义在别的文件中，使用 extern 可以在多个源文件中共享某个变量。extern 跟 static 在含义上是“水火不容”的，一个表示不能在别的地方用，一个表示要去别的地方找。如果同时使用的话，一定要先使用 static，后使用 extern ，否则结果是未定义的。</p>
<h3 id="newmalloc区别">new、malloc区别</h3>
<ol>
<li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li>
<li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li>
<li>malloc失败返回空指针，new失败抛出异常</li>
</ol>
<h3 id="定义只能在堆栈上创建的对象">定义只能在堆/栈上创建的对象</h3>
<p>只能在堆上：将析构函数设置为私有</p>
<p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p>
<p>只能在栈上：将 new 和 delete 重载为私有</p>
<p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>
<h3 id="auto_ptr-与-unique_ptr-比较">auto_ptr 与 unique_ptr 比较</h3>
<p>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义；
auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）；</p>
<h3 id="类型安全">类型安全</h3>
<p>C++不是类型安全的，可以发生两个指针之间的强制转换；C#是类型安全的。</p>
<h3 id="在const成员函数中赋值">在const成员函数中赋值</h3>
<p>去掉const，两种方式</p>
<ol>
<li>mutable，无视const</li>
<li>const_cast转换，强制去掉，也能去掉volatile</li>
</ol>
<h3 id="两种隐式转换方式">两种隐式转换方式</h3>
<ol>
<li>单参构造函数，或除了第一个其他都是默认参数的构造函数；</li>
<li>重载()运算符，()前面加上你想要隐式转换的类型</li>
</ol>
<h3 id="构造函数调用虚函数">构造函数调用虚函数</h3>
<p>不能，语法上通过，语义上有问题。
derived class对象内的base class成分会在derived class自身构造之前构造完毕。因此，在base class的构造函数中执行的virtual函数将会是base class的版本，决不会是derived class的版本。
即使目前确实正在构造derived class。</p>
<h3 id="浅拷贝导致的悬垂指针">浅拷贝导致的悬垂指针</h3>
<p>一般来讲浅拷贝是够用的，也就是编译器默认的拷贝行为。但类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。如果此时B中执行析构函数释放掉指向那一块堆的指针，这时A内的指针就将成为悬挂指针。</p>
<h3 id="virtual函数声明为内联">virtual函数声明为内联</h3>
<p>inline是编译期决定，他意味着在执行前就将调用动作替换为被调用函数的本体；virtual是运行期决定，他意味着直道运行期才决定调用哪个函数。二者是冲突的。</p>
<p>但是，当编译阶段就已经知道调用虚函数的指针为多态指针，就是可以的。比如不是通过基类而是派生类的指针访问函数。</p>
<h3 id="实现一个不能被继承的类">实现一个不能被继承的类</h3>
<p>用final修饰</p>
<h3 id="类a包含类b除了include之外的方法">类A包含类B，除了#include之外的方法</h3>
<p>前置声明，然后使用它的引用或者指针。友元和typedef也可以使用。</p>
<p>优点：</p>
<ol>
<li>减小了类A的大小；</li>
<li>只需要重新编译B而不需要重新编译A，提高了编译速度，减少了编译时依赖；</li>
<li>降低了耦合</li>
</ol>
<p>使用前置声明只允许的声明是指针或引用的一个原因是只要这个声明没有执行需要了解类A的大小或者成员的操作就可以了，所以声明成指针或引用是没有执行需要了解类A的大小或者成员的操作的。</p>
<p>当我们需要知道这个类型的大小或者需要知道它的函数签名的时候，我们就需要获得它的定义。</p>
<p>缺点：</p>
<ol>
<li>编译期不能发现错误，可能在运行期出错。</li>
</ol>
<p>模板编程中常用前置声明，项目中不建议使用。</p>
<h3 id="gdb调试命令">gdb调试命令</h3>
<ol>
<li>list 显示源码</li>
<li>run 运行程序</li>
<li>continue 中断后继续运行到下一个断点</li>
<li>step 单步进入</li>
<li>next 单步执行</li>
<li>call 调用某个函数</li>
<li>(backtrace)bt 查看栈</li>
<li>bt N 显示开头N个栈桢</li>
<li>bt -N 显示最后N个栈桢</li>
<li>(frame)f N 显示第N层栈桢</li>
<li>set directory 设置gdb的工作目录</li>
<li>pwd 当前的工作目录</li>
<li>break 函数名 设置断在某个函数</li>
<li>break 文件名:行号 设置断在某一行</li>
<li>info break 查看设置的断点信息</li>
<li>break if condition 条件断点</li>
<li>break 函数名 thread 线程号 设置断点只断某个线程，通过info threads 查看线程号</li>
<li>delete 断点号 断点号… 删除一个或多个断点</li>
<li>disable 断点号 断点号… 禁止一个或多个断点</li>
<li>enable 断点号 断点号… 打开一个或多个断点</li>
<li>command 断点号 断点触发时，执行命令，一般用于打印变量</li>
<li>print {type} xx （以某种格式）打印变量</li>
</ol>
<h3 id="网络编程">网络编程</h3>
<p>同步和异步的概念描述的是用户线程与内核的交互方式：同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；而异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。</p>
<p>阻塞和非阻塞的概念描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。</p>
<h3 id="stl">STL</h3>
<p>对std::vector任何操作，一旦引起空间重新配置，指向原有vector的迭代器就都失效了。因为动态增加大小并不是在原空间后面接续新空间，而是以原大小两倍另外配置一块，再将原内容拷贝过来，并释放原空间。如果一边遍历一边插入可能就会产生这个问题，但是一边遍历一边删除则不会，只是需要将erase返回的迭代器作为原迭代器的下一步前进。即earase只会造成指向被删除元素的那个迭代器失效。</p>
<p>对于std::list不存在这个问题，因为存储空间不需要是连续空间，所以插入和接合操作都不会造成原有迭代器的失效，每次插入或者删除一个元素，就配置或是放一个元素空间，非常精准。</p>

    
    
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: '36c8fa6e09d08297a270',
    clientSecret: 'af0175944284956d288d14b389fbc89be8df7f1e',
    repo: 'chongg039.github.io',
    owner: 'chongg039',
    admin: ['chongg039'],
    id: location.pathname, 
    distractionFreeMode: false 
  });
  (function() {
    if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
      document.getElementById('gitalk-container').innerHTML = 'Gitalk comments not available by default when the website is previewed locally.';
      return;
    }
    gitalk.render('gitalk-container');
  })();
</script>

<div class="navfooter">
    <table width="100%" summary="Navigation footer">
        <tbody>
            <tr>
                <td width="40%" align="left">&nbsp;</td>
                <td width="20%" align="center">&nbsp;</td>
                <td width="40%" align="right">&nbsp;</td>
            </tr>
            <tr>
                <td width="40%" align="left" valign="top">
                    <span class="copyright">
                        Copyright 2014-2020
                    </span>
                    &nbsp;
                </td>
                <td width="20%" align="center">&nbsp;</td>
                <td width="40%" align="right" valign="top">&nbsp;<a href="https://chongg039.cn/">HOME</a></td>
            </tr>
        </tbody>
    </table>
</div>
</body>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: { 
            inlineMath: [ ['$','$'], ['\\(','\\)'] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true
        }
    });
    </script>
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-117991024-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    <script type="text/javascript" src="https://chongg039.cn/js/function.js"></script>
    <script type="text/javascript" src="https://chongg039.cn/js/prettify.js"></script>
    
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
</html>

