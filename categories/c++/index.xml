<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Co1driver 的个人博客</title>
    <link>https://chongg039.cn/categories/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Co1driver 的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright 2014-{year}</copyright>
    <lastBuildDate>Sat, 22 Feb 2020 11:01:40 +0800</lastBuildDate>
    
	<atom:link href="https://chongg039.cn/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[设计模式系列]装饰模式与组合模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-5/</link>
      <pubDate>Sat, 22 Feb 2020 11:01:40 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-5/</guid>
      <description>这篇来学习一下装饰模式与组合模式，也是结构型模式中的内容。
装饰模式(Decorator Pattern) 顾名思义，装饰模式就是往一个现有的产品上添加功能部件，增加一些新的额外职责，将这个被嵌入的对象称为职责。注意这不是对所有的类都进行添加，而是对某些实例化的对象进行添加。并且，所有的装饰应该继承同一个装饰接口。
与Bridge模式很相似，侧重的也是单一职责与组合代替继承。考虑和之前相同的例子，对于题干Stem和解题过程，可以将抽取实体和关系的行为与其分离，作为行为装饰在具体的对象中。
// sentence基类，将装饰行为与其分离 class Sentence { public: virtual ~Sentence() = default; virtual void ShowDecorate() = 0; }; // stem子类实例 class Stem : public Sentence { public: void ShowDecorate() override; }; // solution子类实例 class Solution : public Sentence { public: void ShowDecorate() override; }; // 装饰行为基类 class Decorator : public Sentence { public: explicit Decorator(Sentence *sentence); ~Decorator() override; void ShowDecorate() override; private: Sentence *sentence_; }; // 装饰类EntityDecorator class EntityDecorator : public Decorator { public: explicit EntityDecorator(Sentence *sentence); void ShowDecorate() override; private: void ExtractEntity(); }; // 装饰类RelationDecorator class RelationDecorator : public Decorator { public: explicit RelationDecorator(Sentence *sentence); void ShowDecorate() override; private: void ExtractRelation(); }; void Stem::ShowDecorate() { std::cout &amp;lt;&amp;lt; &amp;#34;stem&amp;#39;s decorator&amp;#34; &amp;lt;&amp;lt; std::endl; } void Solution::ShowDecorate() { std::cout &amp;lt;&amp;lt; &amp;#34;solution&amp;#39;s decorator&amp;#34; &amp;lt;&amp;lt; std::endl; } Decorator::Decorator(Sentence *sentence) : sentence_(sentence) {} Decorator::~Decorator() { if (sentence_) { delete sentence_; sentence_ = nullptr; } } void Decorator::ShowDecorate() { sentence_-&amp;gt;ShowDecorate(); } EntityDecorator::EntityDecorator(Sentence *sentence) : Decorator(sentence) {} void EntityDecorator::ShowDecorate() { Decorator::ShowDecorate(); ExtractEntity(); } void EntityDecorator::ExtractEntity() { std::cout &amp;lt;&amp;lt; &amp;#34;extract some entities&amp;#34; &amp;lt;&amp;lt; std::endl; } RelationDecorator::RelationDecorator(Sentence *sentence) : Decorator(sentence) {} void RelationDecorator::ShowDecorate() { Decorator::ShowDecorate(); ExtractRelation(); } void RelationDecorator::ExtractRelation() { std::cout &amp;lt;&amp;lt; &amp;#34;extract some relations&amp;#34; &amp;lt;&amp;lt; std::endl; } 注意装饰器基类要继承Sentence接口的方法，现在我们的程序就可以这么写：</description>
    </item>
    
    <item>
      <title>[设计模式系列]桥接模式与适配器模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-4/</link>
      <pubDate>Fri, 21 Feb 2020 21:04:39 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-4/</guid>
      <description>这篇文章进入GOF中的结构型模式篇幅。
Bridge模式 桥接模式号称设计模式中最难理解的模式，同时用好了能够很大程度上降低模块之间的耦合程度。因为本质上桥接模式实现了抽象化(Abstraction)与实现化(Implementation)的解耦，将继承关系转变为了组合关系，减少了代码编写量。
说得通俗一点，就是一个实现中若涉及多个不同层次的继承关系，如果不将其合理解耦，则会产生很多设计上冗余的代码。cabinriver写的这篇文章中举了一个非常棒的例子，我也暂时没有想到更合适的，就在这里重复一下，方便学习记录。感谢他的工作。
一台电脑可能有不同的制造商，每台电脑又可以安装多种不同的操作系统。电脑上在生产一台电脑时，需要生产出安装了不同操作系统的电脑。那么我们就应该将操作系统这个继承体系分离出去：
// 操作系统 class OS { public: virtual ~OS() = default; virtual void Run() = 0; }; class Linux : public OS { public: void Run() override; }; class Windows : public OS { public: void Run() override; }; // 不同品牌的电脑 class Computer { public: virtual ~Computer() = default; virtual void Install(OS *os) = 0; }; class Dell : public Computer { public: void Install(OS *os) override; }; class Apple : public Computer { public: void Install(OS *os) override; }; void Linux::Run() { std::cout &amp;lt;&amp;lt; &amp;#34;Linux running.</description>
    </item>
    
    <item>
      <title>[基础知识]计算机网络</title>
      <link>https://chongg039.cn/post/network-base/</link>
      <pubDate>Thu, 20 Feb 2020 20:32:59 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/network-base/</guid>
      <description></description>
    </item>
    
    <item>
      <title>[基础知识]操作系统</title>
      <link>https://chongg039.cn/post/os-base/</link>
      <pubDate>Thu, 20 Feb 2020 20:32:11 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/os-base/</guid>
      <description>回顾和整理操作系统相关的知识点以及C++实现。
用户态与内核态 用户态与内核态是Linux的体系结构，也叫用户空间和内核空间，用户态是提供应用程序运行的空间，内核态就是控制计算机硬件运行的那部分特殊的软件运行的空间。用户态的程序想要访问这些硬件资源，内核态必须为之提供一组访问接口，这些接口就被称为系统调用(System Call)。
一般来讲，软件运行在用户态。但当程序需要调用操作系统提供的某一服务，如打开文件、连接设备、fork进程等，就需要切换至内核态，此时进程也就不进行相应的工作了，取而代之的是内核在进行某些处理。
中断是计算机在执行程序时，出现某些特殊的情况导致CPU暂停对指令的执行，转而去处理这项特殊的事务，处理完之后再回去处理先前的任务。中断一般有三类：
 由硬件异常或故障引起的内部异常中断； 由程序中的中断指令引起的软中断； 由外部设备请求引起的外部中断。  我们最为关心的是软中断。当一个进程发出一个系统调用的请求之后，会产生一个软中断，此时系统会对这个软中断进行处理，这样便从用户态切换到了内核态。理论上，这三种中断均可以从用户态切换到内核态。
进程、线程和协程 进程(process)是资源分配的基本单位，一般由代码块、数据区、堆、栈段组成。线程(thread)是CPU调度的基本单位，是进程的一个实体，可独立运行。一个进程一般由多个线程构成，且多个线程可以并发执行。
在同一个进程中，多个线程共享该进程的代码段（代码、常量）、数据段（全局变量、静态变量）和扩展段（堆存储），但拥有各自的栈段，用来存放所有的局部变量和临时变量、程序计数器、线程id和寄存器组中的值。
协程(coroutine)是一种轻量级的用户态的线程，与线程的特点基本一样，但避免了无意义的调度和内核切换的开销，但同时带来的是编写者需要自己承担调度携程的责任，且只能模拟多任务并发，无法使用多核CPU进行并行操作。
PCB与进程的创建 进程控制块(Process Control Block, PCB)是进程实体的一部分，是操作系统中最重要的记录型数据结构。PCB中记录了操作系统所需要的、用于描述进程情况及控制进程运行所需要的全部信息。主要包含以下四个部分：
 唯一标识一个进程的进程标识符，有外部标识符和内部标识符； 处理机状态信息； 进程调度信息； 进程控制信息。  系统按照以下流程创建进程：
 分配、初始化PCB； 初始化机器寄存器； 拷贝、初始化内存页表； 从硬盘加载程序代码到内存； 将进程添加至就绪队列； 进程调度时，选择该进程，切换至用户态开始执行该进程。  进程调度算法 操作系统通过进程调度算法快速切换进程，使得每个进程都有一定的时间片来响应用户提交的请求，基本的调度算法有：
FCFS先来先服务 简单，效率低，对长作业有利，对短作业不利；在CPU繁忙型作业上表现可以，不适用于IO繁忙型。
时间片轮转 还是先来先服务，但是每个进程只能运行一个预设的时间片，一个时间片内未完，该进程就必须被剥夺，释放处理器给下一个就绪的进程，并返回就绪队列的末尾等待下一次被调度。因此时间片的选取至关重要，过大退化为FCFS，过小则会频繁切换进程，增大处理器的时间开销导致真正服务于进程的时间变少。
SJF短作业优先 优先调度短作业，长作业可能会产生”饥饿“现象，同时也没有考虑到作业的紧迫程度。
优先级调度 分为剥夺式与非剥夺式：
 非剥夺式优先级调度指当某个进程正在CPU上运行时，有某个更为重要的进程进入了就绪队列，仍让当前进程继续运行，直到其由于自身原因让出处理器，再将处理器分配给更重要的那个进程； 剥夺式优先级调度是指当某个更为重要的进程进入就绪队列时，立即暂停正在运行的进程，将处理器分配给更重要的这个。  多级反馈队列(带优先级的时间片轮转) 算法思想：
 设置多个就绪队列，每个具有不同的优先级，第1级优先级最高，依次降低； 优先级越高的队列中时间片越短，不同就绪队列中时间片依次递增； 每个就绪队列中按照FCFS进行调度； 每次进来一个新的进程，放入第一级就绪队列，并等待调度； 若被调度的进程能够在时间片内执行完，就可从系统中撤离；若没有执行完，将其转入下一级就绪队列的末尾，排队等待调度； 当进程被转入最后一级优先级队列，按照时间片轮转进行调度； 调度程序从高优先级的就绪队列中开始调度，当且仅当该队列为空才从下一级队列开始调度； 若处理器正在执行某进程，又有新的进程添加到了优先级更高的就绪队列中，则立即抢占处理器，将正在执行的进程放入当前就绪队列的末尾，并将处理器分配给更高优先级的进程。  同步与通信 线程之间共享资源，但拥有各自不同的运行栈，进程之间互相隔离。线程并发需要解决的是同步问题，进程则需要解决通信问题。
线程同步 原子操作可以是一个步骤，也可以是按照某个顺序的多个步骤，但是不能被切割，具有整体性。一旦开始就必须执行到结束，中间不能被线程调度机制打断。原子操作是不需要同步的，需要线程同步的根本原因在于对普通变量的操作不是原子的。
涉及原子操作的关键字：synchronize、volatile、atomic。
每个进程中访问临界资源的那部分代码被称为临界区，是每次仅允许一个进程访问的共享资源。互斥访问临界资源一般可以通过信号量(semaphore)或互斥锁(mutex)进行。临界资源数量为1时信号量将退化为锁。
进程通信IPC 管道一般有无名管道和命名管道FIFO。无名管道是unix中IPC最古老的形式，一般由一个读文件描述符fd[0]和写文件描述符fd[1]组成，半双工，只能用于父子进程、兄弟进程之间的通信，是一种存在与内存中的特殊的文件系统。FIFO可以在无关进程之间交换数据，管道中先进先出，是一种文件类型，有路径名。</description>
    </item>
    
    <item>
      <title>[设计模式系列]建造者模式和原型模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-3/</link>
      <pubDate>Thu, 20 Feb 2020 10:32:08 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-3/</guid>
      <description>本篇再来学习一下GOF中提到的创建型模式的最后两种：建造者模式(Builder Pattern)和原型模式(Prototype Pattern)。
建造者模式(Builder Pattern) Builder模式的作用是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。和抽象工厂模式有类似之处，建造者模式也是用来创建大而复杂的对象，只不过更强调按照某种顺序一步步构建的这个过程，并且通过相同的创建过程可以获得不同的最终对象。
一般而言建造者模式由一个Builder基类和一个具体的Director类构成。与抽象工厂模式不同的另一点在于Builder一般不直接返回一个对象，只是规定了所有属性的接口和初始化顺序，具体的对象生成工作交由Director中的一个方法来完成。
考虑上篇文章那个例子，我们要为Stem、SubStem、Option和Solution生成要保存的信息，假设每个里面都需要按顺序初始化下面两个部分：
// InfoBuilder class InfoBuilder { public: virtual ~InfoBuilder() = default; // 构建Entity部分  virtual void BuildEntityPart() = 0; // 构建Relation部分  virtual void BuildRelationPart() = 0; }; // 题干信息Builder class StemInfoBuilder : public InfoBuilder { public: void BuildEntityPart() override; void BuildRelationPart() override; }; // 小问信息Builder class SubStemInfoBuilder : public InfoBuilder { public: void BuildEntityPart() override; void BuildRelationPart() override; }; // InfoDirector class InfoDirector { public: explicit InfoDirector(InfoBuilder *info_builder); ~InfoDirector(); void Construct(); private: InfoBuilder *info_builder_; }; void StemInfoBuilder::BuildEntityPart() { std::cout &amp;lt;&amp;lt; &amp;#34;now build entity part for stem&amp;#34; &amp;lt;&amp;lt; std::endl; } void StemInfoBuilder::BuildRelationPart() { std::cout &amp;lt;&amp;lt; &amp;#34;now build relation part for stem&amp;#34; &amp;lt;&amp;lt; std::endl; } void SubStemInfoBuilder::BuildEntityPart() { std::cout &amp;lt;&amp;lt; &amp;#34;now build entity part for sub_stem&amp;#34; &amp;lt;&amp;lt; std::endl; } void SubStemInfoBuilder::BuildRelationPart() { std::cout &amp;lt;&amp;lt; &amp;#34;now build relation part for sub_stem&amp;#34; &amp;lt;&amp;lt; std::endl; } InfoDirector::InfoDirector(InfoBuilder *info_builder) : info_builder_(info_builder) {} InfoDirector::~InfoDirector() { if (info_builder_) { delete info_builder_; info_builder_ = nullptr; } } void InfoDirector::Construct() { info_builder_-&amp;gt;BuildEntityPart(); info_builder_-&amp;gt;BuildRelationPart(); } 注意我这个析构函数使用了delete，也就是代表指针指向的一定是堆上new出来的资源，不能是构造出来的对象再取地址。即：</description>
    </item>
    
    <item>
      <title>[设计模式系列]工厂模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-2/</link>
      <pubDate>Wed, 19 Feb 2020 15:41:09 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-2/</guid>
      <description>这一节再来讨论一下工厂模式，主要分为三种：简单工厂模式、工厂方法模式和抽象工厂模式。其实说实话我觉得工厂模式比单例模式还要直观一点，因为这就是多态基类实例化子类的方式，自然而然就能想到。
考虑以下这个实例，一份完整的数学选择题应该会包含如下几个部分：
 题干部分(stem) 小问部分(sub_stem) 选项部分(option) 解答过程(solution)  在进行设计时，需要对这四个部分抽象出相同的特性。那么这四个部分不论怎么变化，首先都是“语句(sentence)”（这里并不是指字符串的意思）。那么我们就可以在Sentence基类的基础上讨论工厂方法的实现方式。
// 基类, 不能被实例化 class Sentence { public: virtual ~Sentence() = default; virtual void ShowMsg() = 0; }; // 题干 class Stem : public Sentence { public: void ShowMsg() override { std::cout &amp;lt;&amp;lt; &amp;#34;this is a stem&amp;#34; &amp;lt;&amp;lt; std::endl; }; }; // 小问 class SubStem : public Sentence { public: void ShowMsg() override { std::cout &amp;lt;&amp;lt; &amp;#34;this is a sub_stem&amp;#34; &amp;lt;&amp;lt; std::endl; }; }; // 选项 class Option : public Sentence { public: void ShowMsg() override { std::cout &amp;lt;&amp;lt; &amp;#34;this is an option&amp;#34; &amp;lt;&amp;lt; std::endl; }; }; // 解答过程 class Solution : public Sentence { public: void ShowMsg() override { std::cout &amp;lt;&amp;lt; &amp;#34;this is a solution&amp;#34; &amp;lt;&amp;lt; std::endl; }; }; 简单工厂模式(Simple Factory) 简单工厂模式就是多态，C++中基类的指针或引用都可以调用子类的虚函数达到多态的效果，看例子：</description>
    </item>
    
    <item>
      <title>[设计模式系列]单例模式</title>
      <link>https://chongg039.cn/post/design-pattern-series-1/</link>
      <pubDate>Mon, 17 Feb 2020 17:01:20 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/design-pattern-series-1/</guid>
      <description>开一个新坑，记录一下设计模式的学习和使用经过。因为最近在写一个项目，首先接触到的和思考的就是单例模式，就从这里写起吧。
出发点 有时候不论是出于易用性考虑还是效率上的考虑，我们希望某些资源仅被初始化一次，但是其他所有的实例都可以使用它。大部分情况下这类资源是不会被改动的，当然也会有意外，一旦涉及到改动可能有需要考虑线程安全的问题。
听起来是不是和static全局对象的作用很相似？不过如果你能记起Effective C++中的内容，就会知道静态全局变量的初始化顺序是完全看编译器的心情的。虽然同一个编译单元内的静态全局变量初始化顺序是一定的，但若是不同编译单元内的静态全局变量产生了相互依赖，结果可能就会变得不可预料。
但我们可以通过一个静态的方法，获取只初始化一次的实例对象。这就是单例模式的实现方式。
需要定义的方法和成员变量  既然是需要访问这个全局实例，一定是通过一个静态的类方法获取这个实例的指针或者引用； 单例类不能有公有的构造函数，那么一个共有的析构函数也就变得没有意义； 显然单例类不能有任何公有的拷贝和赋值的行为； 单例类应该需要有一个指向全局唯一实例的指针，为了让静态方法能够获取到这个实例指针，该指针也应该是静态的。  暂时就想到这么多，下面再来思考单例类实例化的时机。是的，单例类要有一个全局唯一的实例，且又不能在外部显示实例化，那就只有一个方法，将构造函数声明为私有的或者保护的，并在某些时刻调用它。
根据调用单例类实例化的时机，可将其分为懒汉版单例模式（Lazy Singleton）和饿汉版单例模式（Eager Singleton）。
Lazy Singleton 顾名思义，什么是懒汉，就是不到万不得已不进行实例的初始化操作，也就是第一次调用GetInstance获取实例对象时才进行初始化：
// 单例模式 class Singleton { public: static Singleton *GetInstance(); // 禁止拷贝和赋值, delete需要在public中实现  Singleton(const Singleton &amp;amp;) = delete; Singleton &amp;amp;operator=(const Singleton &amp;amp;) = delete; private: Singleton(); ~Singleton(); static Singleton *instance; }; Singleton *Singleton::instance = nullptr; Singleton *Singleton::GetInstance() { if (instance == nullptr) { instance = new Singleton(); } return instance; } Singleton::Singleton() { std::cout &amp;lt;&amp;lt; &amp;#34;singleton ctor&amp;#34; &amp;lt;&amp;lt; std::endl; } Singleton::~Singleton() { std::cout &amp;lt;&amp;lt; &amp;#34;singleton dtor&amp;#34; &amp;lt;&amp;lt; std::endl; } 然后我们在main函数中观察一下实例化的时机：</description>
    </item>
    
    <item>
      <title>[基础知识]C&#43;&#43;基础知识汇总</title>
      <link>https://chongg039.cn/post/cxx-base/</link>
      <pubDate>Sun, 20 Oct 2019 15:51:31 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/cxx-base/</guid>
      <description>指针和引用 联系 C++底层中引用是通过指针实现的，在实现层面上引用就是指针，指向同一对象的内存地址。
所有对引用的操作就是对原始对象的操作。
区别  引用只是别名，不是实体类型，因此编译器不为引用分配单独的内存空间，而指针有自己的内存空间，因此某种程度上指针不能被引用取代； 引用必须被初始化且不能为空，但可以有未初始化的空指针； 引用一旦初始化就不能更换目标，即不能被初始化多次，指针可以更改指向的对象； 可以有指针数组，不能有引用数组，因为引用没有被分配内存； 当引用作为函数的形参时，因为函数形参和实参是同一个对象，避免了复制对象的开销； 若对引用型参数做const修饰，则不会调用拷贝构造函数，提高效率； 若引用作为函数的返回结果，需要保证函数返回后被引用的目标一直有效，即不能返回函数内部的局部对象的引用（因为离开作用域后会被析构掉）。  数组和指针 C++不记录数组本身的大小，因此一定注意不要越界访问。
数组作为形参传递时会退化为同类型的指针：
int data[] = {1, 2, 3, 4, 5}; int size1 = sizeof(data); // 20 int *data2 = data; int size2 = sizeof(data2); // 4  int GetSize(int data[]) { return sizeof(data); } int size3 = GetSize(data); // 4 sizeof使用与陷阱 https://www.cnblogs.com/chio/archive/2007/06/11/778934.html
内存对齐 尽管计算机中内存是按照字节byte划分的，但不是寻址可以从任意的byte开始。一般来说计算机会对基本数据类型数据在内存中存放的位置加以限制，要求首地址必须是某个数（一般是4和8）的倍数，这就是内存对齐。
因为虽然计算机按照字节划分存储空间，但处理器存取一次内存不是按照一个字节存取的，一般以双字节、4字节、8字节甚至到32字节存取。这被称为内存存取粒度。
对32位处理器的int类型（4字节），若数据现在可以存放在任一字节开始处，会产生性能的损失。比如，现在从地址1字节开始存放int（1-5，左开右闭），读取时从0字节开始读取一个4字节大小的块，需要访问两次内存。第一步先读取0-4左开右闭字节快，剔除0地址字节；第二步访问4-8左开右闭字节快，剔除5、6、7三个字节块。然后将这两部分得到的合并放入寄存器，需要做很多工作。有了内存对齐，那么只能从规定的边界存放和读取，访问一次内存就可以了。
设置编译器的”对齐系数(对齐模数)“的预处理指令为#pragma pack(n)，linux下gcc默认n=4。还有一个概念为”对齐单位“，也称有效对齐值，是指n和结构体中最长数据类型（基本数据类型）长度中较小的那一个值。
下面说一下内存对齐规则，主要有两条：
 结构体中第一个成员的offset为0，之后每个成员都相对首地址的offset都是”该成员大小“和”对齐单位“中较小的那个的整数倍。如有需要可以添加进填充字节； 结构体的总大小为”对齐单位“的整数倍，如有需要会在最末尾成员添加填充字节。  分析下下面三个例子：
#pragma pack(4)// 先使用第一条规则 // 对x, 对齐单位min(4, 4) = 4, 按照4字节对齐, 不用偏移, 从0开始占用4个字节 // 对c1, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从4开始占用1个字节 // 对c2, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从5开始占用1个字节 // 再使用第二条规则, 结构体大小需要是对齐单位的整数倍, 补2个字节在末尾 // sizeof(x1) = 8 typedef struct x1 { int x; char c1; char c2; } x1; // 先使用第一条规则 // 对c1, 对齐单位min(4, 1) = 1, 按照1字节对齐, 不用偏移, 从0开始占用1个字节 // 对c2, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从1开始占用1个字节 // 对x, 对齐单位min(4, 4) = 4, 按照4字节对齐, 相对于首地址偏移min(4, 4) = 4的倍数, 需要先填充2位, 再从4开始占用4个字节 // 再使用第二条规则, 结构体大小需要是对齐单位的整数倍, 不用补填充字节 // sizeof(x2) = 8 typedef struct x2 { char c1; char c2; int x; } x2; // 先使用第一条规则 // 对c1, 对齐单位min(4, 1) = 1, 按照1字节对齐, 不用偏移, 从0开始占用1个字节 // 对x, 对齐单位min(4, 4) = 4, 按照4字节对齐, 相对于首地址偏移min(4, 4) = 1的倍数, 需要先填充3位, 再从4开始占用4个字节 // 对c2, 对齐单位min(4, 1) = 1, 按照1字节对齐, 相对于首地址偏移min(1, 1) = 1的倍数, 从8开始占用1个字节 // 再使用第二条规则, 结构体大小需要是对齐单位的整数倍, 补3个字节在末尾 // sizeof(x3) = 12 typedef struct x3 { char c1; int x; char c2; } x3; #pragma pack()准确地讲这是属于内存的字节对齐。还有一个问题是大端对齐和小端对齐，这和处理器的架构有关系。大端对齐模式就是数据的低位保存在内存的高地址，内存的低地址存放着数据的高位。小端对齐模式就是数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。一般都是使用小端对齐的方式，大端对齐主要用在一些大型机的处理器中。</description>
    </item>
    
  </channel>
</rss>