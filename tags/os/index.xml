<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OS on Co1driver 的个人博客</title>
    <link>https://chongg039.cn/tags/os/</link>
    <description>Recent content in OS on Co1driver 的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright 2014-{year}</copyright>
    <lastBuildDate>Thu, 20 Feb 2020 20:32:11 +0800</lastBuildDate><atom:link href="https://chongg039.cn/tags/os/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[基础知识]操作系统</title>
      <link>https://chongg039.cn/post/os-base/</link>
      <pubDate>Thu, 20 Feb 2020 20:32:11 +0800</pubDate>
      
      <guid>https://chongg039.cn/post/os-base/</guid>
      <description>回顾和整理操作系统相关的知识点以及C++实现。
用户态与内核态 用户态与内核态是Linux的体系结构，也叫用户空间和内核空间，用户态是提供应用程序运行的空间，内核态就是控制计算机硬件运行的那部分特殊的软件运行的空间。用户态的程序想要访问这些硬件资源，内核态必须为之提供一组访问接口，这些接口就被称为系统调用(System Call)。
一般来讲，软件运行在用户态。但当程序需要调用操作系统提供的某一服务，如打开文件、连接设备、fork进程等，就需要切换至内核态，此时进程也就不进行相应的工作了，取而代之的是内核在进行某些处理。
中断是计算机在执行程序时，出现某些特殊的情况导致CPU暂停对指令的执行，转而去处理这项特殊的事务，处理完之后再回去处理先前的任务。中断一般有三类：
 由硬件异常或故障引起的内部异常中断； 由程序中的中断指令引起的软中断； 由外部设备请求引起的外部中断。  我们最为关心的是软中断。当一个进程发出一个系统调用的请求之后，会产生一个软中断，此时系统会对这个软中断进行处理，这样便从用户态切换到了内核态。理论上，这三种中断均可以从用户态切换到内核态。
进程、线程和协程 进程(process)是资源分配的基本单位，一般由代码块、数据区、堆、栈段组成。线程(thread)是CPU调度的基本单位，是进程的一个实体，可独立运行。一个进程一般由多个线程构成，且多个线程可以并发执行。
在同一个进程中，多个线程共享该进程的代码段（代码、常量）、数据段（全局变量、静态变量）和扩展段（堆存储），但拥有各自的栈段，用来存放所有的局部变量和临时变量、程序计数器、线程id和寄存器组中的值。
协程(coroutine)是一种轻量级的用户态的线程，与线程的特点基本一样，但避免了无意义的调度和内核切换的开销，但同时带来的是编写者需要自己承担调度协程的责任，且只能模拟多任务并发，无法使用多核CPU进行并行操作。
PCB与进程的创建 进程控制块(Process Control Block, PCB)是进程实体的一部分，是操作系统中最重要的记录型数据结构。PCB中记录了操作系统所需要的、用于描述进程情况及控制进程运行所需要的全部信息。主要包含以下四个部分：
 唯一标识一个进程的进程标识符，有外部标识符和内部标识符； 处理机状态信息； 进程调度信息； 进程控制信息。  系统按照以下流程创建进程：
 分配、初始化PCB； 初始化机器寄存器； 拷贝、初始化内存页表； 从硬盘加载程序代码到内存； 将进程添加至就绪队列； 进程调度时，选择该进程，切换至用户态开始执行该进程。  进程调度算法 操作系统通过进程调度算法快速切换进程，使得每个进程都有一定的时间片来响应用户提交的请求，基本的调度算法有：
FCFS先来先服务 简单，效率低，对长作业有利，对短作业不利；在CPU繁忙型作业上表现可以，不适用于IO繁忙型。
时间片轮转 还是先来先服务，但是每个进程只能运行一个预设的时间片，一个时间片内未完，该进程就必须被剥夺，释放处理器给下一个就绪的进程，并返回就绪队列的末尾等待下一次被调度。因此时间片的选取至关重要，过大退化为FCFS，过小则会频繁切换进程，增大处理器的时间开销导致真正服务于进程的时间变少。
SJF短作业优先 优先调度短作业，长作业可能会产生”饥饿“现象，同时也没有考虑到作业的紧迫程度。
优先级调度 分为剥夺式与非剥夺式：
 非剥夺式优先级调度指当某个进程正在CPU上运行时，有某个更为重要的进程进入了就绪队列，仍让当前进程继续运行，直到其由于自身原因让出处理器，再将处理器分配给更重要的那个进程； 剥夺式优先级调度是指当某个更为重要的进程进入就绪队列时，立即暂停正在运行的进程，将处理器分配给更重要的这个。  多级反馈队列(带优先级的时间片轮转) 算法思想：
 设置多个就绪队列，每个具有不同的优先级，第1级优先级最高，依次降低； 优先级越高的队列中时间片越短，不同就绪队列中时间片依次递增； 每个就绪队列中按照FCFS进行调度； 每次进来一个新的进程，放入第一级就绪队列，并等待调度； 若被调度的进程能够在时间片内执行完，就可从系统中撤离；若没有执行完，将其转入下一级就绪队列的末尾，排队等待调度； 当进程被转入最后一级优先级队列，按照时间片轮转进行调度； 调度程序从高优先级的就绪队列中开始调度，当且仅当该队列为空才从下一级队列开始调度； 若处理器正在执行某进程，又有新的进程添加到了优先级更高的就绪队列中，则立即抢占处理器，将正在执行的进程放入当前就绪队列的末尾，并将处理器分配给更高优先级的进程。  同步与通信 线程之间共享资源，但拥有各自不同的运行栈，进程之间互相隔离。线程并发需要解决的是同步问题，进程则需要解决通信问题。
线程同步 原子操作可以是一个步骤，也可以是按照某个顺序的多个步骤，但是不能被切割，具有整体性。一旦开始就必须执行到结束，中间不能被线程调度机制打断。原子操作是不需要同步的，需要线程同步的根本原因在于对普通变量的操作不是原子的。
涉及原子操作的关键字：synchronize、volatile、atomic。
每个进程中访问临界资源的那部分代码被称为临界区，是每次仅允许一个进程访问的共享资源。互斥访问临界资源一般可以通过信号量(semaphore)或互斥锁(mutex)进行。临界资源数量为1时信号量将退化为锁。
进程通信IPC 管道一般有无名管道和命名管道FIFO。无名管道是unix中IPC最古老的形式，一般由一个读文件描述符fd[0]和写文件描述符fd[1]组成，半双工，只能用于父子进程、兄弟进程之间的通信，是一种存在与内存中的特殊的文件系统。FIFO可以在无关进程之间交换数据，管道中先进先出，是一种文件类型，有路径名。</description>
    </item>
    
  </channel>
</rss>
